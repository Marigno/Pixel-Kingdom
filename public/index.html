<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Kingdom - Lightweight MMORPG</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #111;
            color: #eee;
            position: fixed; /* Prevent body scrolling on mobile */
            width: 100%;
            height: 100%;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #character-creation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            pointer-events: auto;
            border: 2px solid #555;
        }
        .hidden {
            display: none !important;
        }
        input, select, button {
            display: block;
            margin: 10px auto;
            padding: 8px;
            width: 80%;
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
            font-size: 16px; /* Larger for mobile */
        }
        button {
            background-color: #553388;
            cursor: pointer;
            transition: background-color 0.2s;
            padding: 12px 8px;
        }
        button:hover {
            background-color: #6644aa;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 10;
        }
        #chat {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 350px;
            max-width: calc(100% - 220px);
            height: 180px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            pointer-events: auto;
            z-index: 10;
        }
        #chat-messages {
            height: 150px;
            overflow-y: auto;
            padding: 5px;
            font-size: 14px;
            margin-bottom: 30px; /* Add space for input field */
        }
        #chat-input {
            position: absolute;
            bottom: 5px;
            left: 5px;
            width: calc(100% - 20px);
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
        }
        .chat-message {
            margin-bottom: 3px;
            word-wrap: break-word;
        }
        .chat-system { color: #aaccff; }
        .chat-player { color: #aaffcc; }
        .chat-whisper { color: #ffaacc; }
        #player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            min-width: 100px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 10;
        }
        #online-count {
            text-align: center;
            font-weight: bold;
        }
        #player-details {
            display: none;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        #player-list.expanded #player-details {
            display: block;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px;
            border-bottom: 1px solid #444;
        }
        .player-name {
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-info {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .health-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #cc3333;
        }
        #inventory {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            width: 200px;
            height: 150px;
            z-index: 10;
        }
        .inventory-slot {
            display: inline-block;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            margin: 2px;
        }
        #health-bar {
            position: absolute;
            top: 50px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #cc3333;
        }
        #mana-bar {
            position: absolute;
            top: 70px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #mana-fill {
            height: 100%;
            width: 100%;
            background-color: #3366cc;
        }
        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 12px;
            line-height: 15px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
        }
        #reconnect-token {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            pointer-events: auto;
            border: 2px solid #555;
            z-index: 20;
        }
        #token-text {
            word-break: break-all;
            background-color: #1a1a1a;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        .loading-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            transition: opacity 0.3s;
            opacity: 0;
            z-index: 20;
        }
        .loading-indicator.active {
            opacity: 1;
        }
        
        /* Mobile controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            width: 100%;
            display: none;
            z-index: 10;
            pointer-events: auto;
        }
        
        /* Virtual joystick */
        .joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            touch-action: none;
            user-select: none;
        }
        
        .joystick-handle {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(85, 51, 136, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.6);
            touch-action: none;
        }

        /* Mobile action buttons */
        .action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .mobile-button {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        /* Mobile UI buttons */
        .ui-buttons {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .ui-button {
            width: 44px;
            height: 44px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        /* Player count button specific styling */
        #btn-players {
            position: relative;
            font-size: 18px;
        }
        
        #btn-players-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: #553388;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Tab key indicator */
        #tab-indicator {
            position: absolute;
            top: 10px;
            right: 120px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 3px;
            display: none;
            z-index: 10;
        }
        
        /* Media Queries for Mobile */
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
                gap: 20px;
            }
            #chat {
                max-width: calc(100% - 20px);
                width: calc(100% - 20px);
                height: 120px;
                bottom: 180px;
                left: 10px;
                z-index: 15;
                /* Fix for mobile keyboard issues */
                position: fixed;
            }
            #chat-messages {
                height: 90px;
                margin-bottom: 25px; /* Space for chat input on mobile */
            }
            #health-bar, #mana-bar {
                width: 100px;
            }
            #inventory {
                width: 200px;
                height: 150px;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 30;
            }
            #tab-indicator {
                display: none;
            }
            #player-list {
                display: none !important; /* Completely hide desktop player list on mobile */
            }
            .connection-status {
                font-size: 10px;
                top: 2px;
            }
            .ui-buttons {
                top: 10px;
                right: 10px;
            }
            .action-buttons {
                bottom: 30px;
                right: 20px;
                flex-direction: row;
            }
        }

        /* Additional mobile-specific styles */
        @media (max-width: 768px) {
            .full-text {
                display: none;
            }
        }

        /* Add CSS for connection status indicator */
        .connection-status {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: #ffcc00;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        .connection-status.connected {
            color: #33cc33;
            opacity: 0;
        }
        .connection-status.disconnected {
            color: #cc3333;
        }
        .connection-status.connecting {
            color: #ffcc00;
        }

        /* Add new styles for player list modal */
        #player-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 300px;
            z-index: 30;
            border: 2px solid #555;
            display: none;
            pointer-events: auto; /* Ensure the modal can receive clicks */
        }
        
        #player-modal h3 {
            margin-top: 0;
            text-align: center;
        }
        
        #player-modal-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        #player-modal .close-button {
            margin-top: 15px;
            background-color: #553388;
            color: #eee;
            border: none;
            padding: 8px 15px;
            width: 100%;
            border-radius: 3px;
            cursor: pointer;
        }
        
        #player-modal .close-button:hover {
            background-color: #6644aa;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- ThreeJS will render here -->
    </div>

    <div id="ui-overlay">
        <div id="character-creation">
            <h2>Welcome to Pixel Kingdom</h2>
            <p>Create your character to begin exploring</p>
            <input type="text" id="character-name" placeholder="Choose your character name" maxlength="20">
            <select id="character-class">
                <option value="warrior">Warrior</option>
                <option value="mage">Mage</option>
                <option value="ranger">Ranger</option>
            </select>
            <div>
                <button id="start-new">Start Adventure</button>
                <button id="show-token-input">Import Character</button>
            </div>
            <div id="token-import" class="hidden">
                <input type="text" id="token-input" placeholder="Paste your character token here">
                <button id="import-token">Import</button>
            </div>
        </div>

        <div id="reconnect-token" class="hidden">
            <h2>Your Character Token</h2>
            <p>Save this token to transfer your character to another device:</p>
            <div id="token-text"></div>
            <button id="copy-token">Copy Token</button>
            <button id="close-token">Close</button>
        </div>

        <div id="stats" class="hidden">
            <div id="character-info">Name: <span id="char-name"></span> | Level: <span id="char-level">1</span></div>
        </div>

        <div id="player-list" class="hidden">
            <h3><span class="full-text">Players </span>Online: <span id="online-count">1</span></h3>
            <div id="player-details"></div>
        </div>

        <div id="health-bar" class="hidden">
            <div id="health-fill"></div>
            <div class="progress-text">100/100</div>
        </div>

        <div id="mana-bar" class="hidden">
            <div id="mana-fill"></div>
            <div class="progress-text">50/50</div>
        </div>

        <div id="inventory" class="hidden">
            <h3>Inventory</h3>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
        </div>

        <div id="chat" class="hidden">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Press Enter to chat...">
        </div>

        <div id="loading-indicator" class="loading-indicator">Loading resources...</div>
        
        <div id="mobile-controls" class="hidden">
            <div class="joystick-container" id="joystick-container">
                <div class="joystick-handle" id="joystick-handle"></div>
            </div>
            <div class="action-buttons">
                <div id="btn-action" class="mobile-button">⚔️</div>
                <div id="btn-interact" class="mobile-button">👋</div>
            </div>
            <div class="ui-buttons">
                <div id="btn-chat" class="ui-button">💬</div>
                <div id="btn-inventory" class="ui-button">🎒</div>
                <div id="btn-players" class="ui-button">👥<div id="btn-players-count">1</div></div>
            </div>
        </div>
        
        <div id="tab-indicator">Press Tab to show players</div>

        <div id="player-modal" class="hidden">
            <h3>Players Online: <span id="modal-online-count">0</span></h3>
            <div id="player-modal-list"></div>
            <button class="close-button">Close</button>
        </div>
    </div>

    <div id="connection-status" class="connection-status">Connecting...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
        
        // Game configuration
        const CONFIG = {
            WORLD_SIZE: 100,
            TILE_SIZE: 1,
            MOVEMENT_SPEED: 5,
            WEBSOCKET_URL: location.protocol === 'https:' 
                ? 'wss://' + location.host 
                : 'ws://' + location.host,
            SAVE_INTERVAL: 30000, // Save character every 30 seconds
            DEBUG: true, // Enable debug logging
        };

        // Game state
        let gameState = {
            player: null,
            otherPlayers: {},
            worldChunks: {},
            loadedChunks: new Set(),
            itemsInWorld: [],
            npcs: [],
            gameTime: 0,
            lastSaveTime: 0
        };

        // Collision detection system
        const collisionSystem = {
            // Map boundary constraints
            mapBounds: {
                minX: -CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2,
                maxX: CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2,
                minZ: -CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2,
                maxZ: CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2
            },
            
            // Collection of obstacles
            obstacles: [],
            
            // Add an obstacle to the collision system
            addObstacle: function(position, radius, type) {
                this.obstacles.push({
                    position: position,
                    radius: radius,
                    type: type
                });
            },
            
            // Check if a position is within map bounds
            isInBounds: function(position) {
                return position.x >= this.mapBounds.minX && 
                       position.x <= this.mapBounds.maxX && 
                       position.z >= this.mapBounds.minZ && 
                       position.z <= this.mapBounds.maxZ;
            },
            
            // Check if a position collides with any obstacle
            checkCollision: function(position, radius = 0.5) {
                // First check map bounds
                if (!this.isInBounds(position)) {
                    return true; // Collision with map bounds
                }
                
                // Then check obstacles
                for (let obstacle of this.obstacles) {
                    const distance = Math.sqrt(
                        Math.pow(position.x - obstacle.position.x, 2) + 
                        Math.pow(position.z - obstacle.position.z, 2)
                    );
                    
                    if (distance < (radius + obstacle.radius)) {
                        return true; // Collision with obstacle
                    }
                }
                
                return false; // No collision
            },
            
            // Get valid position closest to target
            getValidPosition: function(current, target, radius = 0.5) {
                // If target is valid, return it directly
                if (!this.checkCollision(target, radius)) {
                    return target;
                }
                
                // Otherwise, find the furthest valid position along the path
                const direction = new THREE.Vector3(
                    target.x - current.x,
                    target.y - current.y,
                    target.z - current.z
                ).normalize();
                
                const maxDistance = Math.sqrt(
                    Math.pow(target.x - current.x, 2) + 
                    Math.pow(target.z - current.z, 2)
                );
                
                let validPosition = {
                    x: current.x,
                    y: current.y,
                    z: current.z
                };
                
                // Binary search for the furthest valid position
                let minDist = 0;
                let maxDist = maxDistance;
                
                for (let i = 0; i < 10; i++) { // 10 iterations should be enough
                    const testDist = (minDist + maxDist) / 2;
                    const testPos = {
                        x: current.x + direction.x * testDist,
                        y: current.y,
                        z: current.z + direction.z * testDist
                    };
                    
                    if (this.checkCollision(testPos, radius)) {
                        maxDist = testDist;
                    } else {
                        minDist = testDist;
                        validPosition = testPos;
                    }
                }
                
                return validPosition;
            }
        };

        // Main game components
        let scene, camera, renderer, clock;
        let controls, playerMesh, worldGroup, itemsGroup, playerGroup;
        let websocket;
        let isLoggedIn = false;

        // UI elements
        const characterCreation = document.getElementById('character-creation');
        const reconnectToken = document.getElementById('reconnect-token');
        const statsUI = document.getElementById('stats');
        const chatUI = document.getElementById('chat');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const playerList = document.getElementById('player-list');
        const onlinePlayers = document.getElementById('online-players');
        const healthBar = document.getElementById('health-bar');
        const manaBar = document.getElementById('mana-bar');
        const inventory = document.getElementById('inventory');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Initialize the game
        function init() {
            try {
                console.log('Initializing game...');
                // Check if there's a saved character
                const savedCharacter = localStorage.getItem('pixelRealmsCharacter');
                if (savedCharacter) {
                    try {
                        gameState.player = JSON.parse(savedCharacter);
                        document.getElementById('char-name').textContent = gameState.player.name;
                        document.getElementById('char-level').textContent = gameState.player.level;
                        updateHealthMana();
                        hideElement(characterCreation);
                        showGameUI();
                        
                        // On mobile, hide chat and inventory by default
                        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                            hideElement(chatUI);
                            hideElement(inventory);
                        }
                        
                        console.log('Initializing game world with saved character');
                        initGameWorld();
                        connectToServer();
                        isLoggedIn = true;
                    } catch (e) {
                        console.error('Error loading saved character', e);
                        // If loading fails, we'll just show character creation
                        localStorage.removeItem('pixelRealmsCharacter');
                        showElement(characterCreation);
                    }
                } else {
                    // If no saved character, just show the creation screen
                    showElement(characterCreation);
                }
                
                // Set up event listeners for character creation
                document.getElementById('start-new').addEventListener('click', createNewCharacter);
                document.getElementById('show-token-input').addEventListener('click', function() {
                    document.getElementById('token-import').classList.toggle('hidden');
                });
                document.getElementById('import-token').addEventListener('click', importCharacter);
                document.getElementById('copy-token').addEventListener('click', copyTokenToClipboard);
                document.getElementById('close-token').addEventListener('click', function() {
                    hideElement(reconnectToken);
                });
                
                // Chat functionality
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        const message = chatInput.value.trim();
                        if (message) {
                            sendChatMessage(message);
                            chatInput.value = '';
                            // On mobile, blur the input to hide keyboard and reset viewport
                            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                                chatInput.blur();
                                // Force scroll adjustment after keyboard disappears
                                setTimeout(() => {
                                    window.scrollTo(0, 0);
                                }, 100);
                            }
                        }
                    }
                    
                    // Prevent any movement keys from triggering while typing
                    if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'space'].includes(e.key.toLowerCase())) {
                        e.stopPropagation();
                    }
                });
                
                console.log('Initialization complete');
            } catch (error) {
                console.error('Error during initialization:', error);
                alert('There was an error initializing the game. Please refresh the page.');
            }
        }

        // Initialize the 3D game world
        function initGameWorld() {
            try {
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x243447); // Dark blue background
                
                // Renderer setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('game-container').appendChild(renderer.domElement);
                
                // Camera setup
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 10);
                camera.lookAt(0, 0, 0);
                
                // Basic lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // Create groups for organization
                worldGroup = new THREE.Group();
                itemsGroup = new THREE.Group();
                playerGroup = new THREE.Group();
                scene.add(worldGroup);
                scene.add(itemsGroup);
                scene.add(playerGroup);
                
                // Create player character
                playerMesh = createCharacterMesh(gameState.player.class);
                playerMesh.position.set(
                    gameState.player.position.x, 
                    gameState.player.position.y, 
                    gameState.player.position.z
                );
                playerGroup.add(playerMesh);
                
                // Add a nametag above the player
                createPlayerNameTag(playerMesh, gameState.player.name);
                
                // Setup camera to follow player
                camera.position.set(
                    playerMesh.position.x, 
                    playerMesh.position.y + 8, 
                    playerMesh.position.z + 8
                );
                camera.lookAt(playerMesh.position);
                
                console.log('Starting world generation');
                // Generate initial world chunks
                generateInitialWorld();
                
                // Setup clock for animations
                clock = new THREE.Clock();
                
                // Setup keyboard controls
                setupControls();
                
                // Start game loop
                animate();
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
                
                console.log('Game world initialization complete');
            } catch (error) {
                console.error('Error initializing game world:', error);
                hideElement(characterCreation);
                addSystemMessage('Error initializing game. Please refresh the page and try again.');
            }
        }

        // Create basic character mesh based on class
        function createCharacterMesh(characterClass) {
            let color;
            switch(characterClass) {
                case 'warrior': color = 0xcc3333; break;
                case 'mage': color = 0x3366cc; break;
                case 'ranger': color = 0x33cc66; break;
                default: color = 0xcccccc;
            }
            
            // Create a simple character model
            const character = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.35;
            character.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.85;
            character.add(head);
            
            return character;
        }

        // Add name tag above player
        function createPlayerNameTag(playerMesh, name) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = '#222222';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(name, canvas.width / 2, canvas.height / 2 + 8);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.y = 1.5;
            sprite.scale.set(2, 0.5, 1);
            
            playerMesh.add(sprite);
            return sprite;
        }

        // Generate the initial world chunks
        function generateInitialWorld() {
            try {
                showLoadingIndicator('Generating world...');
                
                // Create a basic ground plane
                const groundGeometry = new THREE.PlaneGeometry(
                    CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE, 
                    CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE
                );
                groundGeometry.rotateX(-Math.PI / 2);
                
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x507744,
                    side: THREE.DoubleSide
                });
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                worldGroup.add(ground);
                
                // Add some random obstacles and decoration
                addWorldDecoration();
                
                hideLoadingIndicator();
                console.log('World generation complete');
            } catch (error) {
                console.error('Error generating world:', error);
                hideLoadingIndicator();
                addSystemMessage('Error generating world. Please refresh the page.');
            }
        }

        // Add decorative elements to the world
        function addWorldDecoration() {
            // Generate a deterministic seed for consistent map generation
            const seed = 12345;
            // Create a seeded random number generator
            const rng = new Math.seedrandom ? new Math.seedrandom(seed.toString()) : Math.random;
            
            // Add trees
            for (let i = 0; i < 50; i++) {
                const x = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place trees at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createTree(x, 0, z);
            }
            
            // Add rocks
            for (let i = 0; i < 30; i++) {
                const x = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place rocks at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createRock(x, 0, z);
            }
            
            // Add a simple house
            createHouse(10, 0, 10);
        }

        // Create a simple tree
        function createTree(x, y, z) {
            const tree = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.75;
            tree.add(trunk);
            
            // Tree leaves
            const leavesGeometry = new THREE.ConeGeometry(1, 2, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x2D572C });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 2.5;
            tree.add(leaves);
            
            tree.position.set(x, y, z);
            worldGroup.add(tree);
            
            // Add tree to collision system
            collisionSystem.addObstacle({x, y, z}, 1.0, 'tree');
            
            return tree;
        }

        // Create a simple rock
        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.5, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            
            rock.position.set(x, y + 0.25, z);
            rock.rotation.set(
                Math.random() * Math.PI, 
                Math.random() * Math.PI, 
                Math.random() * Math.PI
            );
            
            const scale = 0.7 + Math.random() * 0.6;
            rock.scale.set(scale, scale, scale);
            
            worldGroup.add(rock);
            
            // Add rock to collision system
            collisionSystem.addObstacle({x, y, z}, 0.5 * scale, 'rock');
            
            return rock;
        }

        // Create a simple house
        function createHouse(x, y, z) {
            const house = new THREE.Group();
            
            // House base
            const baseGeometry = new THREE.BoxGeometry(5, 2.5, 4);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xDDCCAA });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1.25;
            house.add(base);
            
            // House roof
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xAA3333 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 3.5;
            roof.rotation.y = Math.PI / 4;
            house.add(roof);
            
            // Door
            const doorGeometry = new THREE.PlaneGeometry(1, 1.8);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x663300, side: THREE.DoubleSide });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.01);
            house.add(door);
            
            // Windows
            const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x88CCFF, side: THREE.DoubleSide });
            
            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(-1.5, 1.5, 2.01);
            house.add(window1);
            
            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(1.5, 1.5, 2.01);
            house.add(window2);
            
            house.position.set(x, y, z);
            worldGroup.add(house);
            
            // Add house to collision system - add each wall separately for better accuracy
            collisionSystem.addObstacle({x, y, z}, 3.0, 'house');
            
            return house;
        }

        // Setup keyboard controls
        function setupControls() {
            const keysPressed = {};
            let isChatActive = false;
            let isJumping = false;
            let targetPosition = null;
            
            // Chat input focus handlers
            chatInput.addEventListener('focus', function() {
                isChatActive = true;
                
                // Reset all movement keys when chat becomes active
                keysPressed['w'] = false;
                keysPressed['a'] = false;
                keysPressed['s'] = false;
                keysPressed['d'] = false;
                keysPressed['arrowup'] = false;
                keysPressed['arrowdown'] = false;
                keysPressed['arrowleft'] = false;
                keysPressed['arrowright'] = false;
            });
            
            chatInput.addEventListener('blur', function() {
                isChatActive = false;
                
                // Adjust viewport on mobile when keyboard disappears
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    window.scrollTo(0, 0);
                }
            });
            
            document.addEventListener('keydown', (event) => {
                // Don't process any movement keys when typing in chat
                if (isChatActive) {
                    return;
                }
                
                keysPressed[event.key.toLowerCase()] = true;
                
                // Tab key to toggle player list details
                if (event.key === 'Tab') {
                    event.preventDefault(); // Prevent tab from changing focus
                    playerList.classList.toggle('expanded');
                }
                
                // Jump action (J key)
                if (event.key.toLowerCase() === 'j' && !isJumping) {
                    performJumpAction();
                }
                
                // Attack action (K key)
                if (event.key.toLowerCase() === 'k') {
                    performAttackAction();
                }
            });
            
            document.addEventListener('keyup', (event) => {
                // Don't process any movement keys when typing in chat
                if (isChatActive && 
                   ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 
                    'c', 'i', 't', ' ', 'space', 'j', 'k'].includes(event.key.toLowerCase())) {
                    return;
                }
                
                keysPressed[event.key.toLowerCase()] = false;
                
                // Additional key actions
                if (!isChatActive) {
                    if (event.key === 'c' || event.key === 'C') {
                        toggleChat();
                    }
                    
                    if (event.key === 'i' || event.key === 'I') {
                        toggleInventory();
                    }
                    
                    if (event.key === 't' || event.key === 'T') {
                        showTokenDialog();
                    }
                }
            });
            
            // Setup mouse controls
            renderer.domElement.addEventListener('click', (event) => {
                if (isChatActive) return;
                
                // Calculate mouse position in normalized device coordinates (-1 to +1)
                const mouse = new THREE.Vector2(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1
                );
                
                // Create raycaster
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                
                // Find intersections with the ground plane
                const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const targetPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(groundPlane, targetPoint);
                
                // Set target position
                targetPosition = {
                    x: targetPoint.x,
                    y: playerMesh.position.y,
                    z: targetPoint.z
                };
                
                // Turn player towards the clicked point immediately
                const dx = targetPosition.x - playerMesh.position.x;
                const dz = targetPosition.z - playerMesh.position.z;
                if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
                    playerMesh.rotation.y = Math.atan2(dx, dz);
                }
            });
            
            // Function to perform jump action
            function performJumpAction() {
                if (isJumping) return;
                
                isJumping = true;
                const originalY = playerMesh.position.y;
                const jumpHeight = 1.5;
                const jumpDuration = 0.5; // in seconds
                const jumpStart = gameState.gameTime;
                
                function animateJump() {
                    const elapsed = gameState.gameTime - jumpStart;
                    const progress = Math.min(elapsed / jumpDuration, 1);
                    
                    // Simple parabolic jump trajectory
                    const height = jumpHeight * Math.sin(progress * Math.PI);
                    playerMesh.position.y = originalY + height;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateJump);
                    } else {
                        // Reset position and jump state
                        playerMesh.position.y = originalY;
                        isJumping = false;
                    }
                }
                
                animateJump();
            }
            
            // Function to perform attack action
            function performAttackAction() {
                // Visual feedback for attack
                const attackIndicator = document.createElement('div');
                attackIndicator.textContent = '⚔️ Attack!';
                attackIndicator.style.position = 'absolute';
                attackIndicator.style.top = '50%';
                attackIndicator.style.left = '50%';
                attackIndicator.style.transform = 'translate(-50%, -50%)';
                attackIndicator.style.color = '#ff3333';
                attackIndicator.style.fontSize = '24px';
                attackIndicator.style.fontWeight = 'bold';
                attackIndicator.style.textShadow = '0 0 5px #000';
                attackIndicator.style.pointerEvents = 'none';
                attackIndicator.style.zIndex = '100';
                document.body.appendChild(attackIndicator);
                
                // Remove after short duration
                setTimeout(() => {
                    document.body.removeChild(attackIndicator);
                }, 500);
                
                // TODO: Implement actual attack logic
                console.log('Attack action performed');
            }
            
            // Setup mobile controls
            setupMobileControls();
            
            // Movement and controls update in animation loop
            controls = {
                keysPressed: keysPressed,
                isChatActive: function() { return isChatActive; },
                moveDirection: new THREE.Vector3(),
                speed: CONFIG.MOVEMENT_SPEED,
                
                update: function(delta) {
                    // Skip movement if chat is active
                    if (this.isChatActive()) return;
                    
                    const moveDirection = new THREE.Vector3();
                    
                    // Handle keyboard movement
                    if (this.keysPressed['w'] || this.keysPressed['arrowup']) moveDirection.z -= 1;
                    if (this.keysPressed['s'] || this.keysPressed['arrowdown']) moveDirection.z += 1;
                    if (this.keysPressed['a'] || this.keysPressed['arrowleft']) moveDirection.x -= 1;
                    if (this.keysPressed['d'] || this.keysPressed['arrowright']) moveDirection.x += 1;
                    
                    // Handle target position movement (from mouse clicks)
                    if (targetPosition) {
                        const dx = targetPosition.x - playerMesh.position.x;
                        const dz = targetPosition.z - playerMesh.position.z;
                        const distSquared = dx * dx + dz * dz;
                        
                        // If we're close enough to the target, stop moving
                        if (distSquared < 0.1) {
                            targetPosition = null;
                        } else {
                            // Calculate normalized direction to target
                            const dist = Math.sqrt(distSquared);
                            moveDirection.x = dx / dist;
                            moveDirection.z = dz / dist;
                        }
                    }
                    
                    if (moveDirection.length() > 0) {
                        moveDirection.normalize();
                        
                        // Calculate new position
                        const newPosition = {
                            x: playerMesh.position.x + moveDirection.x * this.speed * delta,
                            y: playerMesh.position.y,
                            z: playerMesh.position.z + moveDirection.z * this.speed * delta
                        };
                        
                        // Check for collision and get valid position
                        const validPosition = collisionSystem.getValidPosition(
                            {x: playerMesh.position.x, y: playerMesh.position.y, z: playerMesh.position.z},
                            newPosition,
                            0.4 // Player radius
                        );
                        
                        // Move the player
                        playerMesh.position.x = validPosition.x;
                        playerMesh.position.z = validPosition.z;
                        
                        // Update player direction
                        if (moveDirection.x !== 0 || moveDirection.z !== 0) {
                            playerMesh.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                        }
                        
                        // Update camera position
                        camera.position.x = playerMesh.position.x;
                        camera.position.z = playerMesh.position.z + 8;
                        camera.lookAt(playerMesh.position);
                        
                        // Update game state
                        gameState.player.position = {
                            x: playerMesh.position.x,
                            y: playerMesh.position.y,
                            z: playerMesh.position.z
                        };
                        
                        // Send position update to server
                        sendPositionUpdate();
                    }
                }
            };
        }
        
        // Setup mobile controls
        function setupMobileControls() {
            // Show mobile controls on touch devices
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            if (isTouchDevice) {
                const mobileControls = document.getElementById('mobile-controls');
                showElement(mobileControls);
                
                // Setup virtual joystick
                setupVirtualJoystick();
                
                // Setup action buttons
                const btnAction = document.getElementById('btn-action');
                const btnInteract = document.getElementById('btn-interact');
                const btnChat = document.getElementById('btn-chat');
                const btnInventory = document.getElementById('btn-inventory');
                const btnPlayers = document.getElementById('btn-players');
                
                // Action button - can be used for attacks or special actions
                btnAction.addEventListener('touchstart', () => {
                    // Example: trigger attack action
                    console.log('Action button pressed');
                    performAttackAction();
                });
                
                // Interact button - for interacting with NPCs, items, etc.
                btnInteract.addEventListener('touchstart', () => {
                    // Example: trigger interaction with nearby object
                    console.log('Interact button pressed');
                    performJumpAction();
                });
                
                // Chat button
                btnChat.addEventListener('touchend', toggleChat);
                
                // Inventory button
                btnInventory.addEventListener('touchend', toggleInventory);
                
                // Players button (show player modal)
                btnPlayers.addEventListener('touchend', showPlayerModal);
                
                // Set up player modal close button
                document.querySelector('#player-modal .close-button').addEventListener('click', hidePlayerModal);
                
                // Allow player list to toggle on click/tap in desktop mode
                playerList.addEventListener('click', () => {
                    playerList.classList.toggle('expanded');
                });
                
                // Make inventory and player modal draggable on mobile
                makeElementDraggable(inventory);
                makeElementDraggable(document.getElementById('player-modal'));
            }
        }
        
        // Setup virtual joystick
        function setupVirtualJoystick() {
            const joystickContainer = document.getElementById('joystick-container');
            const joystickHandle = document.getElementById('joystick-handle');
            
            let isDragging = false;
            let centerX, centerY, maxDistance;
            let currentX = 0;
            let currentY = 0;
            
            // Helper function to calculate distance between points
            function distance(x1, y1, x2, y2) {
                return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            }
            
            // Initialize joystick when touched
            joystickContainer.addEventListener('touchstart', function(e) {
                e.preventDefault();
                
                const rect = joystickContainer.getBoundingClientRect();
                centerX = rect.left + rect.width / 2;
                centerY = rect.top + rect.height / 2;
                maxDistance = rect.width / 2; // Maximum distance joystick can move
                
                updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
                isDragging = true;
            });
            
            // Handle joystick movement
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                e.preventDefault();
                updateJoystickPosition(e.touches[0].clientX, e.touches[0].clientY);
            });
            
            // Handle touch end - reset joystick
            document.addEventListener('touchend', function(e) {
                if (!isDragging) return;
                
                // Reset joystick to center
                joystickHandle.style.transform = 'translate(-50%, -50%)';
                
                // Reset movement keys
                controls.keysPressed['arrowup'] = false;
                controls.keysPressed['arrowdown'] = false;
                controls.keysPressed['arrowleft'] = false;
                controls.keysPressed['arrowright'] = false;
                
                isDragging = false;
                currentX = 0;
                currentY = 0;
            });
            
            // Update joystick position based on touch
            function updateJoystickPosition(touchX, touchY) {
                // Calculate distance from center
                let dist = distance(centerX, centerY, touchX, touchY);
                
                // Calculate direction vector
                let dirX = touchX - centerX;
                let dirY = touchY - centerY;
                
                // Normalize to max distance
                if (dist > maxDistance) {
                    dirX = dirX / dist * maxDistance;
                    dirY = dirY / dist * maxDistance;
                    dist = maxDistance;
                }
                
                // Move the joystick handle
                joystickHandle.style.transform = `translate(calc(${dirX}px - 50%), calc(${dirY}px - 50%))`;
                
                // Calculate normalized direction (-1 to 1)
                const normalizedX = dirX / maxDistance;
                const normalizedY = dirY / maxDistance;
                
                // Update current position
                currentX = normalizedX;
                currentY = normalizedY;
                
                // Set movement keys based on joystick position
                const deadzone = 0.3; // Minimum movement to trigger direction
                
                controls.keysPressed['arrowup'] = normalizedY < -deadzone;
                controls.keysPressed['arrowdown'] = normalizedY > deadzone;
                controls.keysPressed['arrowleft'] = normalizedX < -deadzone;
                controls.keysPressed['arrowright'] = normalizedX > deadzone;
            }
        }

        // Make an element draggable (for mobile inventory)
        function makeElementDraggable(element) {
            let isDragging = false;
            let offsetX, offsetY;
            
            // Add drag handle
            const dragHandle = document.createElement('div');
            dragHandle.style.width = '100%';
            dragHandle.style.height = '20px';
            dragHandle.style.backgroundColor = 'rgba(85, 51, 136, 0.8)';
            dragHandle.style.borderTopLeftRadius = '5px';
            dragHandle.style.borderTopRightRadius = '5px';
            dragHandle.style.cursor = 'move';
            dragHandle.style.position = 'absolute';
            dragHandle.style.top = '0';
            dragHandle.style.left = '0';
            
            element.style.paddingTop = '25px';
            element.appendChild(dragHandle);
            
            // Touch handlers
            dragHandle.addEventListener('touchstart', function(e) {
                e.preventDefault();
                isDragging = true;
                
                const touch = e.touches[0];
                const rect = element.getBoundingClientRect();
                
                offsetX = touch.clientX - rect.left;
                offsetY = touch.clientY - rect.top;
                
                element.style.transition = 'none';
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                
                const left = touch.clientX - offsetX;
                const top = touch.clientY - offsetY;
                
                // Keep inventory within window bounds
                const maxX = window.innerWidth - element.offsetWidth;
                const maxY = window.innerHeight - element.offsetHeight;
                
                element.style.left = Math.max(0, Math.min(maxX, left)) + 'px';
                element.style.top = Math.max(0, Math.min(maxY, top)) + 'px';
                element.style.transform = 'none';
            });
            
            document.addEventListener('touchend', function() {
                isDragging = false;
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            gameState.gameTime += delta;
            
            // Update controls
            if (controls) controls.update(delta);
            
            // Periodically save character
            if (gameState.gameTime - gameState.lastSaveTime > CONFIG.SAVE_INTERVAL / 1000) {
                saveCharacter();
                gameState.lastSaveTime = gameState.gameTime;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Create a new character
        function createNewCharacter() {
            const name = document.getElementById('character-name').value.trim();
            const characterClass = document.getElementById('character-class').value;
            
            if (!name) {
                alert('Please enter a character name');
                return;
            }
            
            // Create new character
            gameState.player = {
                id: generateUUID(),
                name: name,
                class: characterClass,
                level: 1,
                experience: 0,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                inventory: [],
                position: { x: 0, y: 0, z: 0 },
                created: new Date().toISOString()
            };
            
            // Save character to localStorage
            saveCharacter();
            
            // Update UI
            document.getElementById('char-name').textContent = gameState.player.name;
            document.getElementById('char-level').textContent = gameState.player.level;
            updateHealthMana();
            
            // Hide character creation and show game UI
            hideElement(characterCreation);
            showGameUI();
            
            // Initialize game world
            initGameWorld();
            
            // Connect to server
            connectToServer();
            
            // Show character token
            showTokenDialog();
        }

        // Import character from token
        function importCharacter() {
            const tokenInput = document.getElementById('token-input').value.trim();
            
            if (!tokenInput) {
                alert('Please enter a valid character token');
                return;
            }
            
            try {
                const decodedToken = atob(tokenInput);
                const characterData = JSON.parse(decodedToken);
                
                // Validate character data
                if (!characterData.id || !characterData.name || !characterData.class) {
                    throw new Error('Invalid character data');
                }
                
                // Set as current character
                gameState.player = characterData;
                
                // Save to localStorage
                saveCharacter();
                
                // Update UI
                document.getElementById('char-name').textContent = gameState.player.name;
                document.getElementById('char-level').textContent = gameState.player.level;
                updateHealthMana();
                
                // Hide character creation and show game UI
                hideElement(characterCreation);
                showGameUI();
                
                // Initialize game world
                initGameWorld();
                
                // Connect to server
                connectToServer();
                
                addSystemMessage('Character imported successfully!');
            } catch (e) {
                console.error('Error importing character', e);
                alert('Invalid character token. Please try again.');
            }
        }

        // Show the character token dialog
        function showTokenDialog() {
            const tokenText = document.getElementById('token-text');
            tokenText.textContent = btoa(JSON.stringify(gameState.player));
            showElement(reconnectToken);
        }

        // Copy token to clipboard
        function copyTokenToClipboard() {
            const tokenText = document.getElementById('token-text').textContent;
            navigator.clipboard.writeText(tokenText)
                .then(() => {
                    alert('Token copied to clipboard!');
                })
                .catch(err => {
                    console.error('Error copying token', err);
                    alert('Failed to copy token. Please select and copy it manually.');
                });
        }

        // Debug logging
        function debugLog(message, data) {
            if (CONFIG.DEBUG) {
                console.log(`[DEBUG] ${message}`, data);
            }
        }

        // Connect to WebSocket server
        function connectToServer() {
            showLoadingIndicator('Connecting to server...');
            updateConnectionStatus('connecting', 'Connecting to server...');
            
            debugLog('Attempting to connect to', CONFIG.WEBSOCKET_URL);
            
            // Create WebSocket connection
            websocket = new WebSocket(CONFIG.WEBSOCKET_URL);
            
            websocket.onopen = function() {
                debugLog('Connected to server');
                hideLoadingIndicator();
                updateConnectionStatus('connected', 'Connected');
                
                // Send initial player data
                const initialData = {
                    type: 'player_join',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        class: gameState.player.class,
                        position: gameState.player.position,
                        level: gameState.player.level,
                        health: gameState.player.health,
                        maxHealth: gameState.player.maxHealth
                    }
                };
                
                debugLog('Sending player_join', initialData);
                websocket.send(JSON.stringify(initialData));
                addSystemMessage('Connected to server. Welcome to Pixel Kingdom!');
            };
            
            websocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    debugLog('Received message', data);
                    handleServerMessage(data);
                } catch (err) {
                    debugLog('Error parsing message', err);
                    console.error('Error parsing message:', err, event.data);
                }
            };
            
            websocket.onclose = function(event) {
                debugLog('Disconnected from server', event.code + ': ' + event.reason);
                updateConnectionStatus('disconnected', 'Disconnected. Reconnecting...');
                addSystemMessage('Disconnected from server. Attempting to reconnect...');
                
                // Try to reconnect after a delay
                setTimeout(connectToServer, 3000);
            };
            
            websocket.onerror = function(error) {
                debugLog('WebSocket error', error);
                console.error('WebSocket error:', error);
                hideLoadingIndicator();
                updateConnectionStatus('disconnected', 'Connection error');
                addSystemMessage('Connection error. Please try again later.');
            };
        }
        
        // Update connection status display
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connection-status');
            
            // Remove all status classes
            statusElement.classList.remove('connecting', 'connected', 'disconnected');
            
            // Add the current status class
            statusElement.classList.add(status);
            
            // Set the status message
            statusElement.textContent = message;
            
            // Auto-hide the status after 3 seconds if connected
            if (status === 'connected') {
                setTimeout(() => {
                    statusElement.style.opacity = '0';
                }, 3000);
            } else {
                statusElement.style.opacity = '1';
            }
        }

        // Handle messages from the server
        function handleServerMessage(data) {
            try {
                switch (data.type) {
                    case 'join_confirm':
                        debugLog('Join confirmed', data);
                        break;
                        
                    case 'player_join':
                        // Only process if it's not our own join message
                        if (data.player && data.player.id !== gameState.player.id) {
                            debugLog('Adding other player', data.player);
                            addOtherPlayer(data.player);
                            addSystemMessage(`${data.player.name} has joined the game!`);
                            updatePlayerList();
                        } else {
                            debugLog('Ignoring own player_join message');
                        }
                        break;
                        
                    case 'player_position':
                        // Update other player position
                        if (data.player && data.player.id !== gameState.player.id) {
                            debugLog('Updating player position', data.player);
                            updateOtherPlayerPosition(data.player);
                        }
                        break;
                        
                    case 'chat_message':
                        // Display chat message from other players
                        debugLog('Received chat message', data);
                        if (data.player && data.player.id !== gameState.player.id) {
                            addPlayerMessage(data.player.name, data.message);
                        }
                        break;
                        
                    case 'player_leave':
                        // Remove player who disconnected
                        debugLog('Player leaving', data);
                        if (data.playerId && gameState.otherPlayers[data.playerId]) {
                            removeOtherPlayer(data.playerId);
                            addSystemMessage(`${data.playerName} has left the game.`);
                            updatePlayerList();
                        }
                        break;
                        
                    case 'npc_info':
                        // Add NPC to the game
                        if (data.npc) {
                            addNpcToGame(data.npc);
                        }
                        break;
                        
                    case 'item_info':
                        // Add item to the game
                        if (data.item) {
                            addItemToGame(data.item);
                        }
                        break;
                        
                    default:
                        debugLog('Unknown message type', data.type);
                }
            } catch (e) {
                console.error('Error handling server message', e);
                debugLog('Error handling message', e.message);
            }
        }

        // Send position update to server
        function sendPositionUpdate() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const updateData = {
                    type: 'player_position',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        position: gameState.player.position
                    }
                };
                
                debugLog('Sending position update', updateData);
                websocket.send(JSON.stringify(updateData));
            } else {
                debugLog('Cannot send position update - WebSocket not open');
            }
        }

        // Send chat message
        function sendChatMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const chatData = {
                    type: 'chat_message',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name
                    },
                    message: message
                };
                
                debugLog('Sending chat message', chatData);
                websocket.send(JSON.stringify(chatData));
                addPlayerMessage(gameState.player.name, message);
            } else {
                debugLog('Cannot send chat message - WebSocket not open');
                addSystemMessage('You are not connected to the server.');
            }
        }

        // Add another player to the game
        function addOtherPlayer(playerData) {
            if (!playerData || !playerData.id) {
                debugLog('Invalid player data', playerData);
                return;
            }
            
            // Check if player already exists
            if (gameState.otherPlayers[playerData.id]) {
                debugLog('Player already exists, updating data', playerData);
                // Update player data
                gameState.otherPlayers[playerData.id].data = playerData;
                return;
            }
            
            debugLog('Creating new player mesh', playerData);
            
            // Create player mesh
            const otherPlayerMesh = createCharacterMesh(playerData.class);
            otherPlayerMesh.position.set(
                playerData.position.x,
                playerData.position.y,
                playerData.position.z
            );
            
            // Add name tag
            createPlayerNameTag(otherPlayerMesh, playerData.name);
            
            // Add to scene
            playerGroup.add(otherPlayerMesh);
            
            // Store player data
            gameState.otherPlayers[playerData.id] = {
                data: playerData,
                mesh: otherPlayerMesh
            };
            
            updatePlayerList();
            debugLog('Other player added successfully', playerData.id);
        }
        
        // Remove other player from the game
        function removeOtherPlayer(playerId) {
            const player = gameState.otherPlayers[playerId];
            if (player && player.mesh) {
                debugLog('Removing player from scene', playerId);
                playerGroup.remove(player.mesh);
                delete gameState.otherPlayers[playerId];
                addSystemMessage(`${player.data.name} has left the game.`);
            } else {
                debugLog('Failed to remove player - not found', playerId);
            }
        }

        // Update other player position
        function updateOtherPlayerPosition(playerData) {
            const player = gameState.otherPlayers[playerData.id];
            
            if (!player) {
                debugLog('Player not found for position update, adding them', playerData);
                addOtherPlayer(playerData);
                return;
            }
            
            if (player && player.mesh) {
                // Smoothly move to new position
                const targetPosition = new THREE.Vector3(
                    playerData.position.x,
                    playerData.position.y,
                    playerData.position.z
                );
                
                // Update player direction
                if (player.data.position) {
                    const prevX = player.data.position.x;
                    const prevZ = player.data.position.z;
                    
                    const moveX = playerData.position.x - prevX;
                    const moveZ = playerData.position.z - prevZ;
                    
                    if (Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01) {
                        player.mesh.rotation.y = Math.atan2(moveX, moveZ);
                    }
                }
                
                const currentPosition = player.mesh.position;
                currentPosition.lerp(targetPosition, 0.5);
                
                // Update stored data
                player.data.position = playerData.position;
            } else {
                debugLog('Player mesh not found for position update', playerData.id);
            }
        }
        
        // Add NPC to the game
        function addNpcToGame(npcData) {
            // Implementation will be added later
            console.log('NPC added:', npcData);
        }
        
        // Add item to the game
        function addItemToGame(itemData) {
            // Implementation will be added later
            console.log('Item added:', itemData);
        }

        // Update the player list UI
        function updatePlayerList() {
            // Update player count
            const playerCount = 1 + Object.keys(gameState.otherPlayers).length; // Current player + others
            document.getElementById('online-count').textContent = playerCount;
            document.getElementById('modal-online-count').textContent = playerCount;
            document.getElementById('btn-players-count').textContent = playerCount;
            
            // Update both player lists
            updatePlayerListContent('player-details');
            updatePlayerListContent('player-modal-list');
        }
        
        // Update a specific player list content
        function updatePlayerListContent(elementId) {
            // Clear the list
            const playerContainer = document.getElementById(elementId);
            playerContainer.innerHTML = '';
            
            // Add the current player
            const currentPlayerItem = document.createElement('div');
            currentPlayerItem.className = 'player-item';
            
            const currentPlayerName = document.createElement('div');
            currentPlayerName.className = 'player-name';
            currentPlayerName.textContent = `${gameState.player.name} (You)`;
            
            const currentPlayerInfo = document.createElement('div');
            currentPlayerInfo.className = 'player-info';
            
            const currentPlayerLevel = document.createElement('span');
            currentPlayerLevel.textContent = `Lvl ${gameState.player.level}`;
            
            const healthIndicator = document.createElement('div');
            healthIndicator.className = 'health-indicator';
            healthIndicator.style.backgroundColor = getHealthColor(gameState.player.health, gameState.player.maxHealth);
            
            currentPlayerInfo.appendChild(currentPlayerLevel);
            currentPlayerInfo.appendChild(healthIndicator);
            
            currentPlayerItem.appendChild(currentPlayerName);
            currentPlayerItem.appendChild(currentPlayerInfo);
            playerContainer.appendChild(currentPlayerItem);
            
            // Add other players
            const playerIds = Object.keys(gameState.otherPlayers);
            
            playerIds.forEach(id => {
                const player = gameState.otherPlayers[id];
                
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                const playerName = document.createElement('div');
                playerName.className = 'player-name';
                playerName.textContent = player.data.name;
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                
                const playerLevel = document.createElement('span');
                // Use level from player data if available, default to 1
                const level = player.data.level || 1;
                playerLevel.textContent = `Lvl ${level}`;
                
                const healthInd = document.createElement('div');
                healthInd.className = 'health-indicator';
                // Default to full health if not specified
                const health = player.data.health || 100;
                const maxHealth = player.data.maxHealth || 100;
                healthInd.style.backgroundColor = getHealthColor(health, maxHealth);
                
                playerInfo.appendChild(playerLevel);
                playerInfo.appendChild(healthInd);
                
                playerItem.appendChild(playerName);
                playerItem.appendChild(playerInfo);
                playerContainer.appendChild(playerItem);
            });
        }
        
        // Get color based on health percentage
        function getHealthColor(health, maxHealth) {
            const healthPercent = health / maxHealth;
            
            if (healthPercent > 0.7) {
                return '#33cc33'; // Green
            } else if (healthPercent > 0.3) {
                return '#ffcc00'; // Yellow
            } else {
                return '#cc3333'; // Red
            }
        }

        // Add system message to chat
        function addSystemMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-system';
            messageElement.textContent = `System: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Add player message to chat
        function addPlayerMessage(playerName, message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-player';
            messageElement.textContent = `${playerName}: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Toggle chat visibility
        function toggleChat() {
            chatUI.classList.toggle('hidden');
            if (!chatUI.classList.contains('hidden')) {
                chatInput.focus();
            }
        }

        // Toggle inventory visibility
        function toggleInventory() {
            inventory.classList.toggle('hidden');
        }

        // Update health and mana bars
        function updateHealthMana() {
            const healthFill = document.getElementById('health-fill');
            const manaFill = document.getElementById('mana-fill');
            
            const healthText = healthBar.querySelector('.progress-text');
            const manaText = manaBar.querySelector('.progress-text');
            
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const manaPercent = (gameState.player.mana / gameState.player.maxMana) * 100;
            
            healthFill.style.width = `${healthPercent}%`;
            manaFill.style.width = `${manaPercent}%`;
            
            healthText.textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            manaText.textContent = `${gameState.player.mana}/${gameState.player.maxMana}`;
        }

        // Save character to localStorage
        function saveCharacter() {
            localStorage.setItem('pixelRealmsCharacter', JSON.stringify(gameState.player));
        }

        // Show game UI elements
        function showGameUI() {
            showElement(statsUI);
            showElement(chatUI);
            showElement(playerList);
            showElement(healthBar);
            showElement(manaBar);
            showElement(inventory);
            
            // For mobile, completely hide the player list
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                hideElement(playerList);
            }
        }

        // Show element by removing hidden class
        function showElement(element) {
            element.classList.remove('hidden');
        }

        // Hide element by adding hidden class
        function hideElement(element) {
            element.classList.add('hidden');
        }

        // Show loading indicator
        function showLoadingIndicator(message) {
            const indicator = document.getElementById('loading-indicator');
            indicator.textContent = message || 'Loading...';
            indicator.classList.add('active');
        }

        // Hide loading indicator
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            indicator.classList.remove('active');
        }

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Show player modal dialog
        function showPlayerModal() {
            const playerModal = document.getElementById('player-modal');
            // Use classList to make it consistent with other UI elements
            showElement(playerModal);
            // Also make sure the element is visible since we're using display: none in CSS
            playerModal.style.display = 'block';
            updatePlayerList();
        }
        
        // Hide player modal dialog
        function hidePlayerModal() {
            const playerModal = document.getElementById('player-modal');
            hideElement(playerModal);
            // Also make sure to reset the display style
            playerModal.style.display = 'none';
        }

        // Start the game
        init();
    </script>
</body>
</html>
