<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Kingdom - Lightweight MMORPG</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #111;
            color: #eee;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #character-creation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            pointer-events: auto;
            border: 2px solid #555;
        }
        .hidden {
            display: none !important;
        }
        input, select, button {
            display: block;
            margin: 10px auto;
            padding: 8px;
            width: 80%;
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
        }
        button {
            background-color: #553388;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #6644aa;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #chat {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 350px;
            height: 180px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            pointer-events: auto;
        }
        #chat-messages {
            height: 150px;
            overflow-y: auto;
            padding: 5px;
            font-size: 14px;
        }
        #chat-input {
            position: absolute;
            bottom: 5px;
            left: 5px;
            width: calc(100% - 20px);
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
        }
        .chat-message {
            margin-bottom: 3px;
            word-wrap: break-word;
        }
        .chat-system { color: #aaccff; }
        .chat-player { color: #aaffcc; }
        .chat-whisper { color: #ffaacc; }
        #player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            min-width: 150px;
        }
        #inventory {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            width: 200px;
            height: 150px;
        }
        .inventory-slot {
            display: inline-block;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            margin: 2px;
        }
        #health-bar {
            position: absolute;
            top: 50px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #cc3333;
        }
        #mana-bar {
            position: absolute;
            top: 70px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
        }
        #mana-fill {
            height: 100%;
            width: 100%;
            background-color: #3366cc;
        }
        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 12px;
            line-height: 15px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
        }
        #reconnect-token {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            pointer-events: auto;
            border: 2px solid #555;
        }
        #token-text {
            word-break: break-all;
            background-color: #1a1a1a;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        .loading-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            transition: opacity 0.3s;
            opacity: 0;
        }
        .loading-indicator.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- ThreeJS will render here -->
    </div>

    <div id="ui-overlay">
        <div id="character-creation">
            <h2>Welcome to Pixel Kingdom</h2>
            <p>Create your character to begin exploring</p>
            <input type="text" id="character-name" placeholder="Choose your character name" maxlength="20">
            <select id="character-class">
                <option value="warrior">Warrior</option>
                <option value="mage">Mage</option>
                <option value="ranger">Ranger</option>
            </select>
            <div>
                <button id="start-new">Start Adventure</button>
                <button id="show-token-input">Import Character</button>
            </div>
            <div id="token-import" class="hidden">
                <input type="text" id="token-input" placeholder="Paste your character token here">
                <button id="import-token">Import</button>
            </div>
        </div>

        <div id="reconnect-token" class="hidden">
            <h2>Your Character Token</h2>
            <p>Save this token to transfer your character to another device:</p>
            <div id="token-text"></div>
            <button id="copy-token">Copy Token</button>
            <button id="close-token">Close</button>
        </div>

        <div id="stats" class="hidden">
            <div id="character-info">Name: <span id="char-name"></span> | Level: <span id="char-level">1</span></div>
        </div>

        <div id="player-list" class="hidden">
            <h3>Players Online</h3>
            <div id="online-players"></div>
        </div>

        <div id="health-bar" class="hidden">
            <div id="health-fill"></div>
            <div class="progress-text">100/100</div>
        </div>

        <div id="mana-bar" class="hidden">
            <div id="mana-fill"></div>
            <div class="progress-text">50/50</div>
        </div>

        <div id="inventory" class="hidden">
            <h3>Inventory</h3>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
        </div>

        <div id="chat" class="hidden">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Press Enter to chat...">
        </div>

        <div id="loading-indicator" class="loading-indicator">Loading resources...</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
        
        // Game configuration
        const CONFIG = {
            WORLD_SIZE: 100,
            TILE_SIZE: 1,
            MOVEMENT_SPEED: 5,
            WEBSOCKET_URL: 'wss://pixelkingdom.net/ws', // WebSocket server on your domain
            SAVE_INTERVAL: 30000, // Save character every 30 seconds
        };

        // Game state
        let gameState = {
            player: null,
            otherPlayers: {},
            worldChunks: {},
            loadedChunks: new Set(),
            itemsInWorld: [],
            npcs: [],
            gameTime: 0,
            lastSaveTime: 0
        };

        // Main game components
        let scene, camera, renderer, clock;
        let controls, playerMesh, worldGroup, itemsGroup, playerGroup;
        let websocket;
        let isLoggedIn = false;

        // UI elements
        const characterCreation = document.getElementById('character-creation');
        const reconnectToken = document.getElementById('reconnect-token');
        const statsUI = document.getElementById('stats');
        const chatUI = document.getElementById('chat');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const playerList = document.getElementById('player-list');
        const onlinePlayers = document.getElementById('online-players');
        const healthBar = document.getElementById('health-bar');
        const manaBar = document.getElementById('mana-bar');
        const inventory = document.getElementById('inventory');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Initialize the game
        function init() {
            // Check if there's a saved character
            const savedCharacter = localStorage.getItem('pixelRealmsCharacter');
            if (savedCharacter) {
                try {
                    gameState.player = JSON.parse(savedCharacter);
                    document.getElementById('char-name').textContent = gameState.player.name;
                    document.getElementById('char-level').textContent = gameState.player.level;
                    updateHealthMana();
                    hideElement(characterCreation);
                    showGameUI();
                    initGameWorld();
                    connectToServer();
                    isLoggedIn = true;
                } catch (e) {
                    console.error('Error loading saved character', e);
                    // If loading fails, we'll just show character creation
                }
            }
            
            // Set up event listeners for character creation
            document.getElementById('start-new').addEventListener('click', createNewCharacter);
            document.getElementById('show-token-input').addEventListener('click', function() {
                document.getElementById('token-import').classList.toggle('hidden');
            });
            document.getElementById('import-token').addEventListener('click', importCharacter);
            document.getElementById('copy-token').addEventListener('click', copyTokenToClipboard);
            document.getElementById('close-token').addEventListener('click', function() {
                hideElement(reconnectToken);
            });
            
            // Chat functionality
            chatInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const message = chatInput.value.trim();
                    if (message) {
                        sendChatMessage(message);
                        chatInput.value = '';
                    }
                }
            });
            
            if (!isLoggedIn) {
                // If no saved character, just show the creation screen
                showElement(characterCreation);
            }
        }

        // Initialize the 3D game world
        function initGameWorld() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x243447); // Dark blue background
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // Basic lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create groups for organization
            worldGroup = new THREE.Group();
            itemsGroup = new THREE.Group();
            playerGroup = new THREE.Group();
            scene.add(worldGroup);
            scene.add(itemsGroup);
            scene.add(playerGroup);
            
            // Create player character
            playerMesh = createCharacterMesh(gameState.player.class);
            playerMesh.position.set(
                gameState.player.position.x, 
                gameState.player.position.y, 
                gameState.player.position.z
            );
            playerGroup.add(playerMesh);
            
            // Add a nametag above the player
            createPlayerNameTag(playerMesh, gameState.player.name);
            
            // Setup camera to follow player
            camera.position.set(
                playerMesh.position.x, 
                playerMesh.position.y + 8, 
                playerMesh.position.z + 8
            );
            camera.lookAt(playerMesh.position);
            
            // Generate initial world chunks
            generateInitialWorld();
            
            // Setup clock for animations
            clock = new THREE.Clock();
            
            // Setup keyboard controls
            setupControls();
            
            // Start game loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Create basic character mesh based on class
        function createCharacterMesh(characterClass) {
            let color;
            switch(characterClass) {
                case 'warrior': color = 0xcc3333; break;
                case 'mage': color = 0x3366cc; break;
                case 'ranger': color = 0x33cc66; break;
                default: color = 0xcccccc;
            }
            
            // Create a simple character model
            const character = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.35;
            character.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.85;
            character.add(head);
            
            return character;
        }

        // Add name tag above player
        function createPlayerNameTag(playerMesh, name) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = '#222222';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(name, canvas.width / 2, canvas.height / 2 + 8);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.y = 1.5;
            sprite.scale.set(2, 0.5, 1);
            
            playerMesh.add(sprite);
            return sprite;
        }

        // Generate the initial world chunks
        function generateInitialWorld() {
            showLoadingIndicator('Generating world...');
            
            // Create a basic ground plane
            const groundGeometry = new THREE.PlaneGeometry(
                CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE, 
                CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE
            );
            groundGeometry.rotateX(-Math.PI / 2);
            
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x507744,
                side: THREE.DoubleSide
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            worldGroup.add(ground);
            
            // Add some random obstacles and decoration
            addWorldDecoration();
            
            hideLoadingIndicator();
        }

        // Add decorative elements to the world
        function addWorldDecoration() {
            // Add trees
            for (let i = 0; i < 50; i++) {
                const x = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place trees at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createTree(x, 0, z);
            }
            
            // Add rocks
            for (let i = 0; i < 30; i++) {
                const x = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place rocks at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createRock(x, 0, z);
            }
            
            // Add a simple house
            createHouse(10, 0, 10);
        }

        // Create a simple tree
        function createTree(x, y, z) {
            const tree = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.75;
            tree.add(trunk);
            
            // Tree leaves
            const leavesGeometry = new THREE.ConeGeometry(1, 2, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x2D572C });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 2.5;
            tree.add(leaves);
            
            tree.position.set(x, y, z);
            worldGroup.add(tree);
        }

        // Create a simple rock
        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.5, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            
            rock.position.set(x, y + 0.25, z);
            rock.rotation.set(
                Math.random() * Math.PI, 
                Math.random() * Math.PI, 
                Math.random() * Math.PI
            );
            rock.scale.set(
                0.7 + Math.random() * 0.6,
                0.7 + Math.random() * 0.6,
                0.7 + Math.random() * 0.6
            );
            
            worldGroup.add(rock);
        }

        // Create a simple house
        function createHouse(x, y, z) {
            const house = new THREE.Group();
            
            // House base
            const baseGeometry = new THREE.BoxGeometry(5, 2.5, 4);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xDDCCAA });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1.25;
            house.add(base);
            
            // House roof
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xAA3333 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 3.5;
            roof.rotation.y = Math.PI / 4;
            house.add(roof);
            
            // Door
            const doorGeometry = new THREE.PlaneGeometry(1, 1.8);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x663300, side: THREE.DoubleSide });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.01);
            house.add(door);
            
            // Windows
            const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x88CCFF, side: THREE.DoubleSide });
            
            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(-1.5, 1.5, 2.01);
            house.add(window1);
            
            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(1.5, 1.5, 2.01);
            house.add(window2);
            
            house.position.set(x, y, z);
            worldGroup.add(house);
        }

        // Setup keyboard controls
        function setupControls() {
            const keysPressed = {};
            
            document.addEventListener('keydown', (event) => {
                keysPressed[event.key.toLowerCase()] = true;
            });
            
            document.addEventListener('keyup', (event) => {
                keysPressed[event.key.toLowerCase()] = false;
                
                // Additional key actions
                if (event.key === 'c' || event.key === 'C') {
                    toggleChat();
                }
                
                if (event.key === 'i' || event.key === 'I') {
                    toggleInventory();
                }
                
                if (event.key === 't' || event.key === 'T') {
                    showTokenDialog();
                }
            });
            
            // Movement and controls update in animation loop
            controls = {
                keysPressed: keysPressed,
                moveDirection: new THREE.Vector3(),
                speed: CONFIG.MOVEMENT_SPEED,
                
                update: function(delta) {
                    const moveDirection = new THREE.Vector3();
                    
                    if (this.keysPressed['w']) moveDirection.z -= 1;
                    if (this.keysPressed['s']) moveDirection.z += 1;
                    if (this.keysPressed['a']) moveDirection.x -= 1;
                    if (this.keysPressed['d']) moveDirection.x += 1;
                    
                    if (moveDirection.length() > 0) {
                        moveDirection.normalize();
                        
                        // Move the player
                        playerMesh.position.x += moveDirection.x * this.speed * delta;
                        playerMesh.position.z += moveDirection.z * this.speed * delta;
                        
                        // Update player direction
                        if (moveDirection.x !== 0 || moveDirection.z !== 0) {
                            playerMesh.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                        }
                        
                        // Update camera position
                        camera.position.x = playerMesh.position.x;
                        camera.position.z = playerMesh.position.z + 8;
                        camera.lookAt(playerMesh.position);
                        
                        // Update game state
                        gameState.player.position = {
                            x: playerMesh.position.x,
                            y: playerMesh.position.y,
                            z: playerMesh.position.z
                        };
                        
                        // Send position update to server
                        sendPositionUpdate();
                    }
                }
            };
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            gameState.gameTime += delta;
            
            // Update controls
            if (controls) controls.update(delta);
            
            // Periodically save character
            if (gameState.gameTime - gameState.lastSaveTime > CONFIG.SAVE_INTERVAL / 1000) {
                saveCharacter();
                gameState.lastSaveTime = gameState.gameTime;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Create a new character
        function createNewCharacter() {
            const name = document.getElementById('character-name').value.trim();
            const characterClass = document.getElementById('character-class').value;
            
            if (!name) {
                alert('Please enter a character name');
                return;
            }
            
            // Create new character
            gameState.player = {
                id: generateUUID(),
                name: name,
                class: characterClass,
                level: 1,
                experience: 0,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                inventory: [],
                position: { x: 0, y: 0, z: 0 },
                created: new Date().toISOString()
            };
            
            // Save character to localStorage
            saveCharacter();
            
            // Update UI
            document.getElementById('char-name').textContent = gameState.player.name;
            document.getElementById('char-level').textContent = gameState.player.level;
            updateHealthMana();
            
            // Hide character creation and show game UI
            hideElement(characterCreation);
            showGameUI();
            
            // Initialize game world
            initGameWorld();
            
            // Connect to server
            connectToServer();
            
            // Show character token
            showTokenDialog();
        }

        // Import character from token
        function importCharacter() {
            const tokenInput = document.getElementById('token-input').value.trim();
            
            if (!tokenInput) {
                alert('Please enter a valid character token');
                return;
            }
            
            try {
                const decodedToken = atob(tokenInput);
                const characterData = JSON.parse(decodedToken);
                
                // Validate character data
                if (!characterData.id || !characterData.name || !characterData.class) {
                    throw new Error('Invalid character data');
                }
                
                // Set as current character
                gameState.player = characterData;
                
                // Save to localStorage
                saveCharacter();
                
                // Update UI
                document.getElementById('char-name').textContent = gameState.player.name;
                document.getElementById('char-level').textContent = gameState.player.level;
                updateHealthMana();
                
                // Hide character creation and show game UI
                hideElement(characterCreation);
                showGameUI();
                
                // Initialize game world
                initGameWorld();
                
                // Connect to server
                connectToServer();
                
                addSystemMessage('Character imported successfully!');
            } catch (e) {
                console.error('Error importing character', e);
                alert('Invalid character token. Please try again.');
            }
        }

        // Show the character token dialog
        function showTokenDialog() {
            const tokenText = document.getElementById('token-text');
            tokenText.textContent = btoa(JSON.stringify(gameState.player));
            showElement(reconnectToken);
        }

        // Copy token to clipboard
        function copyTokenToClipboard() {
            const tokenText = document.getElementById('token-text').textContent;
            navigator.clipboard.writeText(tokenText)
                .then(() => {
                    alert('Token copied to clipboard!');
                })
                .catch(err => {
                    console.error('Error copying token', err);
                    alert('Failed to copy token. Please select and copy it manually.');
                });
        }

        // Connect to WebSocket server
        function connectToServer() {
            showLoadingIndicator('Connecting to server...');
            
            // Create WebSocket connection
            websocket = new WebSocket(CONFIG.WEBSOCKET_URL);
            
            websocket.onopen = function() {
                console.log('Connected to server');
                hideLoadingIndicator();
                
                // Send initial player data
                const initialData = {
                    type: 'player_join',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        class: gameState.player.class,
                        position: gameState.player.position,
                        level: gameState.player.level
                    }
                };
                
                websocket.send(JSON.stringify(initialData));
                addSystemMessage('Connected to server. Welcome to Pixel Kingdom!');
            };
            
            websocket.onmessage = function(event) {
                handleServerMessage(event.data);
            };
            
            websocket.onclose = function() {
                console.log('Disconnected from server');
                addSystemMessage('Disconnected from server. Attempting to reconnect...');
                
                // Try to reconnect after a delay
                setTimeout(connectToServer, 3000);
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
                hideLoadingIndicator();
                addSystemMessage('Connection error. Please try again later.');
            };
        }

        // Handle messages from the server
        function handleServerMessage(message) {
            // For demo, we're using an echo server, so we receive our own messages back
            try {
                const data = JSON.parse(message);
                
                switch (data.type) {
                    case 'player_join':
                        // In a real implementation, we would add the player to our game
                        if (data.player.id !== gameState.player.id) {
                            addOtherPlayer(data.player);
                            addSystemMessage(`${data.player.name} has joined the game!`);
                            updatePlayerList();
                        }
                        break;
                        
                    case 'player_position':
                        // Update other player position
                        if (data.player.id !== gameState.player.id) {
                            updateOtherPlayerPosition(data.player);
                        }
                        break;
                        
                    case 'chat_message':
                        // Display chat message
                        if (data.player.id !== gameState.player.id) {
                            addPlayerMessage(data.player.name, data.message);
                        }
                        break;
                }
            } catch (e) {
                console.error('Error parsing server message', e);
            }
        }

        // Send position update to server
        function sendPositionUpdate() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const updateData = {
                    type: 'player_position',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        position: gameState.player.position
                    }
                };
                
                websocket.send(JSON.stringify(updateData));
            }
        }

        // Send chat message
        function sendChatMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const chatData = {
                    type: 'chat_message',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name
                    },
                    message: message
                };
                
                websocket.send(JSON.stringify(chatData));
                addPlayerMessage(gameState.player.name, message);
            } else {
                addSystemMessage('You are not connected to the server.');
            }
        }

        // Add another player to the game
        function addOtherPlayer(playerData) {
            // Check if player already exists
            if (gameState.otherPlayers[playerData.id]) {
                return;
            }
            
            // Create player mesh
            const otherPlayerMesh = createCharacterMesh(playerData.class);
            otherPlayerMesh.position.set(
                playerData.position.x,
                playerData.position.y,
                playerData.position.z
            );
            
            // Add name tag
            createPlayerNameTag(otherPlayerMesh, playerData.name);
            
            // Add to scene
            playerGroup.add(otherPlayerMesh);
            
            // Store player data
            gameState.otherPlayers[playerData.id] = {
                data: playerData,
                mesh: otherPlayerMesh
            };
            
            updatePlayerList();
        }

        // Update other player position
        function updateOtherPlayerPosition(playerData) {
            const player = gameState.otherPlayers[playerData.id];
            
            if (player && player.mesh) {
                // Smoothly move to new position
                const targetPosition = new THREE.Vector3(
                    playerData.position.x,
                    playerData.position.y,
                    playerData.position.z
                );
                
                const currentPosition = player.mesh.position;
                currentPosition.lerp(targetPosition, 0.5);
                
                // Update stored data
                player.data.position = playerData.position;
            }
        }

        // Update the player list UI
        function updatePlayerList() {
            // Clear the list
            onlinePlayers.innerHTML = '';
            
            // Add the current player
            const currentPlayerItem = document.createElement('div');
            currentPlayerItem.textContent = `${gameState.player.name} (You)`;
            onlinePlayers.appendChild(currentPlayerItem);
            
            // Add other players
            const playerIds = Object.keys(gameState.otherPlayers);
            
            playerIds.forEach(id => {
                const player = gameState.otherPlayers[id];
                const playerItem = document.createElement('div');
                playerItem.textContent = `${player.data.name}`;
                onlinePlayers.appendChild(playerItem);
            });
        }

        // Add system message to chat
        function addSystemMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-system';
            messageElement.textContent = `System: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Add player message to chat
        function addPlayerMessage(playerName, message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-player';
            messageElement.textContent = `${playerName}: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Toggle chat visibility
        function toggleChat() {
            chatUI.classList.toggle('hidden');
            if (!chatUI.classList.contains('hidden')) {
                chatInput.focus();
            }
        }

        // Toggle inventory visibility
        function toggleInventory() {
            inventory.classList.toggle('hidden');
        }

        // Update health and mana bars
        function updateHealthMana() {
            const healthFill = document.getElementById('health-fill');
            const manaFill = document.getElementById('mana-fill');
            
            const healthText = healthBar.querySelector('.progress-text');
            const manaText = manaBar.querySelector('.progress-text');
            
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const manaPercent = (gameState.player.mana / gameState.player.maxMana) * 100;
            
            healthFill.style.width = `${healthPercent}%`;
            manaFill.style.width = `${manaPercent}%`;
            
            healthText.textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            manaText.textContent = `${gameState.player.mana}/${gameState.player.maxMana}`;
        }

        // Save character to localStorage
        function saveCharacter() {
            localStorage.setItem('pixelRealmsCharacter', JSON.stringify(gameState.player));
        }

        // Show game UI elements
        function showGameUI() {
            showElement(statsUI);
            showElement(chatUI);
            showElement(playerList);
            showElement(healthBar);
            showElement(manaBar);
            showElement(inventory);
        }

        // Show element by removing hidden class
        function showElement(element) {
            element.classList.remove('hidden');
        }

        // Hide element by adding hidden class
        function hideElement(element) {
            element.classList.add('hidden');
        }

        // Show loading indicator
        function showLoadingIndicator(message) {
            const indicator = document.getElementById('loading-indicator');
            indicator.textContent = message || 'Loading...';
            indicator.classList.add('active');
        }

        // Hide loading indicator
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            indicator.classList.remove('active');
        }

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Start the game
        init();
    </script>
</body>
</html>
