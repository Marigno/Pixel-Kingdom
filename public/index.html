<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Kingdom - Lightweight MMORPG</title>
    
    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="Pixel Kingdom | Open World MMORPG">
    <meta property="og:description" content="Explore a vast pixel world, battle monsters, collect loot, and interact with other players in this lightweight browser-based MMORPG. No downloads required!">
    <meta property="og:image" content="/pixel-kingdom-og.jpg">
    <meta property="og:url" content="https://pixelkingdom.net">
    <meta property="og:type" content="website">
    <meta name="description" content="Pixel Kingdom | Open World MMORPG - A browser-based multiplayer RPG with pixel graphics. Explore, battle, and team up with friends in a vast world.">
    <meta name="twitter:card" content="summary_large_image">
    
    <!-- Favicon -->
    <link rel="icon" type="image/ico" href="/favicon.ico">
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #111;
            color: #eee;
            position: fixed; /* Prevent body scrolling on mobile */
            width: 100%;
            height: 100%;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #character-creation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            pointer-events: auto;
            border: 2px solid #555;
        }
        .hidden {
            display: none !important;
        }
        input, select, button {
            display: block;
            margin: 10px auto;
            padding: 8px;
            width: 80%;
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
            font-size: 16px; /* Larger for mobile */
        }
        button {
            background-color: #553388;
            cursor: pointer;
            transition: background-color 0.2s;
            padding: 12px 8px;
        }
        button:hover {
            background-color: #6644aa;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 10;
        }
        #chat {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 350px;
            max-width: calc(100% - 220px);
            height: 180px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            pointer-events: auto;
            z-index: 10;
        }
        #chat-messages {
            height: 150px;
            overflow-y: auto;
            padding: 5px;
            font-size: 14px;
            margin-bottom: 30px; /* Add space for input field */
        }
        #chat-input {
            position: absolute;
            bottom: 5px;
            left: 5px;
            width: calc(100% - 20px);
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
        }
        .chat-message {
            margin-bottom: 3px;
            word-wrap: break-word;
        }
        .chat-system { color: #aaccff; }
        .chat-player { color: #aaffcc; }
        .chat-whisper { color: #ffaacc; }
        #player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            min-width: 100px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 10;
        }
        #online-count {
            text-align: center;
            font-weight: bold;
        }
        #player-details {
            display: none;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        #player-list.expanded #player-details {
            display: block;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px;
            border-bottom: 1px solid #444;
        }
        .player-name {
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-info {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .health-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #cc3333;
        }
        #inventory {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            width: 300px;
            height: 250px;
            z-index: 20;
            pointer-events: auto;
        }
        .inventory-slot {
            display: inline-block;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            margin: 2px;
        }
        #health-bar {
            position: absolute;
            top: 50px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #cc3333;
        }
        #mana-bar {
            position: absolute;
            top: 70px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #mana-fill {
            height: 100%;
            width: 100%;
            background-color: #3366cc;
        }
        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 12px;
            line-height: 15px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
        }
        #reconnect-token {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            pointer-events: auto;
            border: 2px solid #555;
            z-index: 20;
        }
        #token-text {
            word-break: break-all;
            background-color: #1a1a1a;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        .loading-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            transition: opacity 0.3s;
            opacity: 0;
            z-index: 20;
        }
        .loading-indicator.active {
            opacity: 1;
        }
        
        /* Mobile controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            width: 100%;
            display: none;
            z-index: 10;
            pointer-events: auto;
        }
        
        /* Virtual joystick */
        .joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            touch-action: none;
            user-select: none;
        }
        
        .joystick-handle {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: rgba(85, 51, 136, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.6);
            touch-action: none;
        }

        /* Mobile action buttons */
        .action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .mobile-button {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        /* Mobile UI buttons */
        .ui-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            width: 140px;
            justify-content: flex-end;
        }
        
        .ui-button {
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 50%;
            color: #fff;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        #btn-players {
            position: relative;
        }
        
        #btn-players-count {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: #553388;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Tab key indicator */
        #tab-indicator {
            position: absolute;
            top: 10px;
            right: 120px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 3px;
            display: none;
            z-index: 10;
        }
        
        /* Character screen */
        #character-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 500px;
            height: 80%;
            max-height: 600px;
            z-index: 30;
            display: none;
            pointer-events: auto;
            border: 2px solid #553388;
            overflow: auto;
        }
        
        #character-screen h2 {
            text-align: center;
            color: #aaccff;
            margin-top: 0;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #444;
        }
        
        .stat-name {
            font-weight: bold;
            color: #aaffcc;
        }
        
        .stat-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #ffaaaa;
            cursor: pointer;
            font-size: 20px;
        }
        
        /* Map screen */
        #map-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 800px;
            height: 80%;
            max-height: 600px;
            z-index: 25;
            display: none;
            pointer-events: auto;
            border: 2px solid #553388;
        }
        
        #map-canvas {
            width: 100%;
            height: calc(100% - 40px);
            background-color: #243447;
            border-radius: 5px;
        }
        
        .map-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #ffaaaa;
            cursor: pointer;
            font-size: 20px;
        }
        
        /* Media Queries for Mobile */
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
                gap: 20px;
            }
            #chat {
                max-width: calc(100% - 20px);
                width: calc(100% - 20px);
                height: 120px;
                bottom: 180px;
                left: 10px;
                z-index: 15;
                /* Fix for mobile keyboard issues */
                position: fixed;
            }
            #chat-messages {
                height: 90px;
                margin-bottom: 25px; /* Space for chat input on mobile */
            }
            #health-bar, #mana-bar {
                width: 100px;
            }
            #inventory {
                width: 300px;
                height: 250px;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 30;
            }
            #tab-indicator {
                display: none;
            }
            #player-list {
                display: none !important; /* Completely hide desktop player list on mobile */
            }
            .connection-status {
                font-size: 10px;
                top: 2px;
            }
            .ui-buttons {
                position: fixed;
                top: 10px;
                right: 10px;
                display: flex;
                flex-wrap: wrap;
                width: 130px;
                gap: 5px;
                z-index: 20;
            }
            .action-buttons {
                bottom: 30px;
                right: 20px;
                flex-direction: row;
                gap: 10px;
            }
            .mobile-button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            #character-screen, #map-screen {
                width: 90%;
                height: 90%;
            }
        }

        /* Additional mobile-specific styles */
        @media (max-width: 768px) {
            .full-text {
                display: none;
            }
        }

        /* Add CSS for connection status indicator */
        .connection-status {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: #ffcc00;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        .connection-status.connected {
            color: #33cc33;
            opacity: 0;
        }
        .connection-status.disconnected {
            color: #cc3333;
        }
        .connection-status.connecting {
            color: #ffcc00;
        }

        /* Add new styles for player list modal */
        #player-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 300px;
            z-index: 30;
            border: 2px solid #555;
            display: none;
            pointer-events: auto; /* Ensure the modal can receive clicks */
        }
        
        #player-modal h3 {
            margin-top: 0;
            text-align: center;
        }
        
        #player-modal-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        #player-modal .close-button {
            margin-top: 15px;
            background-color: #553388;
            color: #eee;
            border: none;
            padding: 8px 15px;
            width: 100%;
            border-radius: 3px;
            cursor: pointer;
        }
        
        #player-modal .close-button:hover {
            background-color: #6644aa;
        }

        /* Key bindings help */
        #key-bindings {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 999;
            display: none;
            pointer-events: auto;
        }
        
        #key-bindings h3 {
            margin-top: 0;
            text-align: center;
        }
        
        .key-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        
        .key {
            background-color: #333;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #666;
            margin-left: 10px;
        }
        
        #key-bindings .close-button {
            width: 100%;
            margin-top: 10px;
            background-color: #553388;
            border: none;
            color: white;
            padding: 5px;
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- ThreeJS will render here -->
    </div>

    <div id="ui-overlay">
        <div id="character-creation">
            <h2>Welcome to Pixel Kingdom</h2>
            <p>Create your character to begin exploring</p>
            <input type="text" id="character-name" placeholder="Choose your character name" maxlength="20">
            <select id="character-class">
                <option value="warrior">Warrior</option>
                <option value="mage">Mage</option>
                <option value="ranger">Ranger</option>
            </select>
            <div>
                <button id="start-new">Start Adventure</button>
                <button id="show-token-input">Import Character</button>
            </div>
            <div id="token-import" class="hidden">
                <input type="text" id="token-input" placeholder="Paste your character token here">
                <button id="import-token">Import</button>
            </div>
        </div>

        <div id="reconnect-token" class="hidden">
            <h2>Your Character Token</h2>
            <p>Save this token to transfer your character to another device:</p>
            <div id="token-text"></div>
            <button id="copy-token">Copy Token</button>
            <button id="close-token">Close</button>
        </div>

        <div id="stats" class="hidden">
            <div id="character-info">Name: <span id="char-name"></span> | Level: <span id="char-level">1</span></div>
        </div>

        <div id="player-list" class="hidden">
            <h3><span class="full-text">Players </span>Online: <span id="online-count">1</span></h3>
            <div id="player-details"></div>
        </div>

        <div id="health-bar" class="hidden">
            <div id="health-fill"></div>
            <div class="progress-text">100/100</div>
        </div>

        <div id="mana-bar" class="hidden">
            <div id="mana-fill"></div>
            <div class="progress-text">50/50</div>
        </div>

        <div id="inventory" class="hidden">
            <h3>Inventory</h3>
            <div class="inventory-slots">
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
                <div class="inventory-slot"></div>
            </div>
            <button id="close-inventory" class="close-button">Close</button>
        </div>

        <div id="character-screen" class="hidden">
            <h2>Character Details</h2>
            <button class="stat-close">&times;</button>
            
            <div class="stat-row">
                <span class="stat-name">Name:</span>
                <span id="stat-name">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Class:</span>
                <span id="stat-class">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Level:</span>
                <span id="stat-level">1</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Experience:</span>
                <span id="stat-exp">0/100</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Health:</span>
                <span id="stat-health">100/100</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Mana:</span>
                <span id="stat-mana">50/50</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Strength:</span>
                <span id="stat-str">10</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Dexterity:</span>
                <span id="stat-dex">10</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Intelligence:</span>
                <span id="stat-int">10</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Vitality:</span>
                <span id="stat-vit">10</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Attack Power:</span>
                <span id="stat-atk">15</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Defense:</span>
                <span id="stat-def">5</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Magic Power:</span>
                <span id="stat-mag">10</span>
            </div>
            <div class="stat-row">
                <span class="stat-name">Created:</span>
                <span id="stat-created">-</span>
            </div>
        </div>

        <div id="map-screen" class="hidden">
            <h2>World Map</h2>
            <button class="map-close">&times;</button>
            <canvas id="map-canvas"></canvas>
        </div>

        <div id="chat" class="hidden">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Press Enter to chat...">
        </div>

        <div id="loading-indicator" class="loading-indicator">Loading resources...</div>
        
        <div id="mobile-controls" class="hidden">
            <div class="joystick-container" id="joystick-container">
                <div class="joystick-handle" id="joystick-handle"></div>
            </div>
            <div class="action-buttons">
                <div id="btn-attack" class="mobile-button">‚öîÔ∏è</div>
                <div id="btn-jump" class="mobile-button">‚¨ÜÔ∏è</div>
                <div id="btn-interact" class="mobile-button">üëã</div>
            </div>
            <div class="ui-buttons">
                <div id="btn-chat" class="ui-button">üí¨</div>
                <div id="btn-inventory" class="ui-button">üéí</div>
                <div id="btn-players" class="ui-button">üë•<div id="btn-players-count">1</div></div>
                <div id="btn-character" class="ui-button">üë§</div>
                <div id="btn-map" class="ui-button">üó∫Ô∏è</div>
                <div id="btn-help" class="ui-button">‚ùì</div>
            </div>
        </div>
        
        <div id="tab-indicator">Press Tab to show players</div>

        <div id="player-modal" class="hidden">
            <h3>Players Online: <span id="modal-online-count">0</span></h3>
            <div id="player-modal-list"></div>
            <button class="close-button">Close</button>
        </div>

        <!-- Help screen with key bindings -->
        <div id="key-bindings" class="modal hidden">
            <div class="modal-header">
                <h2>Help & Controls</h2>
                <button class="close-button" onclick="toggleHelp()">√ó</button>
            </div>
            <div class="modal-content">
                <h3>Movement Controls</h3>
                <ul>
                    <li><strong>W</strong> or <strong>‚Üë</strong> - Move forward</li>
                    <li><strong>S</strong> or <strong>‚Üì</strong> - Move backward</li>
                    <li><strong>A</strong> or <strong>‚Üê</strong> - Move left</li>
                    <li><strong>D</strong> or <strong>‚Üí</strong> - Move right</li>
                    <li><strong>Space</strong> - Jump</li>
                    <li><strong>Mouse Click</strong> - Move to location</li>
                </ul>
                
                <h3>Action Controls</h3>
                <ul>
                    <li><strong>E</strong> - Interact with objects/NPCs</li>
                    <li><strong>Ctrl</strong> - Attack</li>
                    <li><strong>Enter</strong> - Open/close chat</li>
                    <li><strong>Tab</strong> - Toggle player list details</li>
                </ul>
                
                <h3>UI Controls</h3>
                <ul>
                    <li><strong>I</strong> - Open/close inventory</li>
                    <li><strong>C</strong> - Open/close character screen</li>
                    <li><strong>M</strong> - Open/close map</li>
                    <li><strong>H</strong> - Open/close this help window</li>
                    <li><strong>T</strong> - Show character token</li>
                </ul>
                
                <p>Mobile users can use the on-screen joystick and buttons for controls.</p>
            </div>
        </div>
    </div>

    <div id="connection-status" class="connection-status">Connecting...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
        
        // Game configuration
        const CONFIG = {
            WORLD_SIZE: 100,
            TILE_SIZE: 1,
            MOVEMENT_SPEED: 5,
            WEBSOCKET_URL: location.protocol === 'https:' 
                ? 'wss://' + location.host 
                : 'ws://' + location.host,
            SAVE_INTERVAL: 30000, // Save character every 30 seconds
            DEBUG: true, // Enable debug logging
        };

        // Game state
        let gameState = {
            player: null,
            otherPlayers: {},
            worldChunks: {},
            loadedChunks: new Set(),
            itemsInWorld: [],
            npcs: [],
            gameTime: 0,
            lastSaveTime: 0
        };

        // Collision detection system
        const collisionSystem = {
            // Map boundary constraints
            mapBounds: {
                minX: -CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2,
                maxX: CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2,
                minZ: -CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2,
                maxZ: CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE / 2
            },
            
            // Collection of obstacles
            obstacles: [],
            
            // Add an obstacle to the collision system
            addObstacle: function(position, radius, type) {
                this.obstacles.push({
                    position: position,
                    radius: radius,
                    type: type
                });
            },
            
            // Check if a position is within map bounds
            isInBounds: function(position) {
                return position.x >= this.mapBounds.minX && 
                       position.x <= this.mapBounds.maxX && 
                       position.z >= this.mapBounds.minZ && 
                       position.z <= this.mapBounds.maxZ;
            },
            
            // Check if a position collides with any obstacle
            checkCollision: function(position, radius = 0.5) {
                // First check map bounds
                if (!this.isInBounds(position)) {
                    return true; // Collision with map bounds
                }
                
                // Then check obstacles
                for (let obstacle of this.obstacles) {
                    const distance = Math.sqrt(
                        Math.pow(position.x - obstacle.position.x, 2) + 
                        Math.pow(position.z - obstacle.position.z, 2)
                    );
                    
                    // Adjust collision radius based on obstacle type for better player proximity
                    let adjustedRadius = obstacle.radius;
                    if (obstacle.type === 'tree') {
                        adjustedRadius = obstacle.radius * 0.7; // Allow closer approach to trees
                    } else if (obstacle.type === 'house') {
                        adjustedRadius = obstacle.radius * 0.8; // Allow closer approach to houses
                    }
                    
                    if (distance < (radius + adjustedRadius)) {
                        return {
                            collides: true,
                            obstacle: obstacle,
                            distance: distance,
                            direction: {
                                x: position.x - obstacle.position.x,
                                z: position.z - obstacle.position.z
                            }
                        };
                    }
                }
                
                return { collides: false }; // No collision
            },
            
            // Get valid position closest to target with improved sliding
            getValidPosition: function(current, target, radius = 0.5) {
                // If target is valid, return it directly
                const collision = this.checkCollision(target, radius);
                if (!collision.collides) {
                    return target;
                }
                
                // For boundary collisions, just clamp to the bounds
                if (!this.isInBounds(target)) {
                    return {
                        x: Math.max(this.mapBounds.minX + radius, Math.min(this.mapBounds.maxX - radius, target.x)),
                        y: target.y,
                        z: Math.max(this.mapBounds.minZ + radius, Math.min(this.mapBounds.maxZ - radius, target.z))
                    };
                }
                
                // For obstacle collisions, implement improved sliding behavior
                const obstacle = collision.obstacle;
                const dirX = target.x - current.x;
                const dirZ = target.z - current.z;
                const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
                
                if (dirLength < 0.001) {
                    return current; // No movement, return current position
                }
                
                // Calculate normalized movement direction
                const normDirX = dirX / dirLength;
                const normDirZ = dirZ / dirLength;
                
                // Get vector from obstacle to target position
                const obstacleToTarget = {
                    x: target.x - obstacle.position.x,
                    z: target.z - obstacle.position.z
                };
                
                // Normalize this vector
                const obstacleDistance = Math.sqrt(
                    obstacleToTarget.x * obstacleToTarget.x + 
                    obstacleToTarget.z * obstacleToTarget.z
                );
                
                const normObstacleToTarget = {
                    x: obstacleToTarget.x / obstacleDistance,
                    z: obstacleToTarget.z / obstacleDistance
                };
                
                // Calculate tangent direction for improved sliding
                const tangentX = -normObstacleToTarget.z;
                const tangentZ = normObstacleToTarget.x;
                
                // Calculate dot product to see how much we're moving along the tangent
                const dotProduct = normDirX * tangentX + normDirZ * tangentZ;
                
                // Apply enhanced sliding - scale based on how much we're already moving in the tangent direction
                const slideFactorX = tangentX * Math.abs(dotProduct) * 1.5; // Increased sliding factor
                const slideFactorZ = tangentZ * Math.abs(dotProduct) * 1.5;
                
                // Adjust collision distance based on obstacle type
                let adjustedRadius = radius + obstacle.radius;
                if (obstacle.type === 'tree') {
                    adjustedRadius *= 0.7; // Allow even closer approach to trees
                } else if (obstacle.type === 'house') {
                    adjustedRadius *= 0.75; // Allow even closer approach to houses
                }
                
                // Calculate new position with improved sliding behavior
                const minDistance = adjustedRadius;
                const pushOutDistance = minDistance - collision.distance;
                
                // Push out along obstacle direction
                const pushX = normObstacleToTarget.x * pushOutDistance;
                const pushZ = normObstacleToTarget.z * pushOutDistance;
                
                // Combine push-out and sliding with higher weight to sliding
                let resultX = current.x + (dirX * 0.4) + (slideFactorX * dirLength) + pushX;
                let resultZ = current.z + (dirZ * 0.4) + (slideFactorZ * dirLength) + pushZ;
                
                // Check if the new position is valid
                const newPos = {
                    x: resultX,
                    y: target.y,
                    z: resultZ
                };
                
                // If the new position is still invalid, just push out from the obstacle
                if (this.checkCollision(newPos, radius).collides) {
                    const safeDistance = radius + obstacle.radius * 0.8 + 0.05; // Reduced safe distance
                    const angle = Math.atan2(obstacleToTarget.z, obstacleToTarget.x);
                    
                    resultX = obstacle.position.x + Math.cos(angle) * safeDistance;
                    resultZ = obstacle.position.z + Math.sin(angle) * safeDistance;
                }
                
                return {
                    x: resultX,
                    y: target.y,
                    z: resultZ
                };
            }
        };

        // Main game components
        let scene, camera, renderer, clock;
        let controls, playerMesh, worldGroup, itemsGroup, playerGroup;
        let websocket;
        let isLoggedIn = false;

        // UI elements
        const characterCreation = document.getElementById('character-creation');
        const reconnectToken = document.getElementById('reconnect-token');
        const statsUI = document.getElementById('stats');
        const chatUI = document.getElementById('chat');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const playerList = document.getElementById('player-list');
        const onlinePlayers = document.getElementById('online-players');
        const healthBar = document.getElementById('health-bar');
        const manaBar = document.getElementById('mana-bar');
        const inventory = document.getElementById('inventory');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Initialize the game
        function init() {
            try {
                console.log('Initializing game...');
                // Check if there's a saved character
                const savedCharacter = localStorage.getItem('pixelRealmsCharacter');
                if (savedCharacter) {
                    try {
                        gameState.player = JSON.parse(savedCharacter);
                        document.getElementById('char-name').textContent = gameState.player.name;
                        document.getElementById('char-level').textContent = gameState.player.level;
                        updateHealthMana();
                        hideElement(characterCreation);
                        showGameUI();
                        
                        // On mobile, hide chat and inventory by default
                        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                            hideElement(chatUI);
                            hideElement(inventory);
                        }
                        
                        console.log('Initializing game world with saved character');
                        initGameWorld();
                        connectToServer();
                        isLoggedIn = true;
                    } catch (e) {
                        console.error('Error loading saved character', e);
                        // If loading fails, we'll just show character creation
                        localStorage.removeItem('pixelRealmsCharacter');
                        showElement(characterCreation);
                    }
                } else {
                    // If no saved character, just show the creation screen
                    showElement(characterCreation);
                }
                
                // Set up event listeners for character creation
                document.getElementById('start-new').addEventListener('click', createNewCharacter);
                document.getElementById('show-token-input').addEventListener('click', function() {
                    document.getElementById('token-import').classList.toggle('hidden');
                });
                document.getElementById('import-token').addEventListener('click', importCharacter);
                document.getElementById('copy-token').addEventListener('click', copyTokenToClipboard);
                document.getElementById('close-token').addEventListener('click', function() {
                    hideElement(reconnectToken);
                });
                
                // Chat functionality
                chatInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        const message = chatInput.value.trim();
                        if (message) {
                            sendChatMessage(message);
                            chatInput.value = '';
                            // On mobile, blur the input to hide keyboard and reset viewport
                            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                                chatInput.blur();
                                // Force scroll adjustment after keyboard disappears
                                setTimeout(() => {
                                    window.scrollTo(0, 0);
                                }, 100);
                            }
                        }
                    }
                    
                    // Prevent any movement keys from triggering while typing
                    if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'space'].includes(e.key.toLowerCase())) {
                        e.stopPropagation();
                    }
                });
                
                console.log('Initialization complete');
            } catch (error) {
                console.error('Error during initialization:', error);
                alert('There was an error initializing the game. Please refresh the page.');
            }
        }

        // Initialize the 3D game world
        function initGameWorld() {
            try {
                // Scene setup
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x243447); // Dark blue background
                
                // Renderer setup
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('game-container').appendChild(renderer.domElement);
                
                // Camera setup
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 10, 10);
                camera.lookAt(0, 0, 0);
                
                // Basic lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // Create groups for organization
                worldGroup = new THREE.Group();
                itemsGroup = new THREE.Group();
                playerGroup = new THREE.Group();
                scene.add(worldGroup);
                scene.add(itemsGroup);
                scene.add(playerGroup);
                
                // Create player character
                playerMesh = createCharacterMesh(gameState.player.class);
                playerMesh.position.set(
                    gameState.player.position.x, 
                    gameState.player.position.y, 
                    gameState.player.position.z
                );
                playerGroup.add(playerMesh);
                
                // Add a nametag above the player
                createPlayerNameTag(playerMesh, gameState.player.name);
                
                // Setup camera to follow player
                camera.position.set(
                    playerMesh.position.x, 
                    playerMesh.position.y + 8, 
                    playerMesh.position.z + 8
                );
                camera.lookAt(playerMesh.position);
                
                console.log('Starting world generation');
                // Generate initial world chunks
                generateInitialWorld();
                
                // Setup clock for animations
                clock = new THREE.Clock();
                
                // Setup keyboard controls
                setupControls();
                
                // Start game loop
                animate();
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
                
                console.log('Game world initialization complete');
            } catch (error) {
                console.error('Error initializing game world:', error);
                hideElement(characterCreation);
                addSystemMessage('Error initializing game. Please refresh the page and try again.');
            }
        }

        // Create basic character mesh based on class
        function createCharacterMesh(characterClass) {
            let color;
            switch(characterClass) {
                case 'warrior': color = 0xcc3333; break;
                case 'mage': color = 0x3366cc; break;
                case 'ranger': color = 0x33cc66; break;
                default: color = 0xcccccc;
            }
            
            // Create a simple character model
            const character = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.35;
            character.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.85;
            character.add(head);
            
            return character;
        }

        // Add name tag above player
        function createPlayerNameTag(playerMesh, name) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = '#222222';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(name, canvas.width / 2, canvas.height / 2 + 8);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.y = 1.5;
            sprite.scale.set(2, 0.5, 1);
            
            playerMesh.add(sprite);
            return sprite;
        }

        // Generate the initial world chunks
        function generateInitialWorld() {
            try {
                showLoadingIndicator('Generating world...');
                
                // Create a basic ground plane
                const groundGeometry = new THREE.PlaneGeometry(
                    CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE, 
                    CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE
                );
                groundGeometry.rotateX(-Math.PI / 2);
                
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x507744,
                    side: THREE.DoubleSide
                });
                
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                worldGroup.add(ground);
                
                // Add some random obstacles and decoration
                addWorldDecoration();
                
                hideLoadingIndicator();
                console.log('World generation complete');
            } catch (error) {
                console.error('Error generating world:', error);
                hideLoadingIndicator();
                addSystemMessage('Error generating world. Please refresh the page.');
            }
        }

        // Add decorative elements to the world
        function addWorldDecoration() {
            // Generate a deterministic seed for consistent map generation
            const seed = 12345;
            // Create a seeded random number generator
            const rng = new Math.seedrandom ? new Math.seedrandom(seed.toString()) : Math.random;
            
            // Add trees
            for (let i = 0; i < 50; i++) {
                const x = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place trees at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createTree(x, 0, z);
            }
            
            // Add rocks
            for (let i = 0; i < 30; i++) {
                const x = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (rng() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place rocks at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createRock(x, 0, z);
            }
            
            // Add a simple house
            createHouse(10, 0, 10);
        }

        // Create a simple tree
        function createTree(x, y, z) {
            const tree = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.75;
            tree.add(trunk);
            
            // Tree leaves
            const leavesGeometry = new THREE.ConeGeometry(1, 2, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x2D572C });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 2.5;
            tree.add(leaves);
            
            tree.position.set(x, y, z);
            worldGroup.add(tree);
            
            // Add tree to collision system
            collisionSystem.addObstacle({x, y, z}, 1.0, 'tree');
            
            return tree;
        }

        // Create a simple rock
        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.5, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            
            rock.position.set(x, y + 0.25, z);
            rock.rotation.set(
                Math.random() * Math.PI, 
                Math.random() * Math.PI, 
                Math.random() * Math.PI
            );
            
            const scale = 0.7 + Math.random() * 0.6;
            rock.scale.set(scale, scale, scale);
            
            worldGroup.add(rock);
            
            // Add rock to collision system
            collisionSystem.addObstacle({x, y, z}, 0.5 * scale, 'rock');
            
            return rock;
        }

        // Create a simple house
        function createHouse(x, y, z) {
            const house = new THREE.Group();
            
            // House base
            const baseGeometry = new THREE.BoxGeometry(5, 2.5, 4);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xDDCCAA });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1.25;
            house.add(base);
            
            // House roof
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xAA3333 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 3.5;
            roof.rotation.y = Math.PI / 4;
            house.add(roof);
            
            // Door
            const doorGeometry = new THREE.PlaneGeometry(1, 1.8);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x663300, side: THREE.DoubleSide });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.01);
            house.add(door);
            
            // Windows
            const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x88CCFF, side: THREE.DoubleSide });
            
            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(-1.5, 1.5, 2.01);
            house.add(window1);
            
            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(1.5, 1.5, 2.01);
            house.add(window2);
            
            house.position.set(x, y, z);
            worldGroup.add(house);
            
            // Add house to collision system - add each wall separately for better accuracy
            collisionSystem.addObstacle({x, y, z}, 3.0, 'house');
            
            return house;
        }

        // Setup keyboard controls
        function setupControls() {
            const keysPressed = {};
            let isChatActive = false;
            let isJumping = false;
            let targetPosition = null;
            
            // Chat input focus handlers
            chatInput.addEventListener('focus', function() {
                isChatActive = true;
                
                // Reset all movement keys when chat becomes active
                keysPressed['w'] = false;
                keysPressed['a'] = false;
                keysPressed['s'] = false;
                keysPressed['d'] = false;
                keysPressed['arrowup'] = false;
                keysPressed['arrowdown'] = false;
                keysPressed['arrowleft'] = false;
                keysPressed['arrowright'] = false;
                keysPressed[' '] = false;
                keysPressed['control'] = false;
                keysPressed['e'] = false;
            });
            
            chatInput.addEventListener('blur', function() {
                isChatActive = false;
                
                // Adjust viewport on mobile when keyboard disappears
                if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                    window.scrollTo(0, 0);
                }
            });
            
            document.addEventListener('keydown', (event) => {
                // Don't process any movement keys when typing in chat
                if (isChatActive) {
                    return;
                }
                
                // Only stop propagation if needed for non-navigation keys
                if (!['Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    event.stopPropagation();
                }
                
                // Store key state using key code for better compatibility
                const key = event.key.toLowerCase();
                keysPressed[key] = true;
                
                // Tab key to toggle player list details
                if (event.key === 'Tab') {
                    event.preventDefault(); // Prevent tab from changing focus
                    playerList.classList.toggle('expanded');
                }
                
                // Enter key to open chat
                if (event.key === 'Enter') {
                    toggleChat();
                    chatInput.focus();
                }
                
                // Space key for jumping
                if (event.key === ' ' && !isJumping) {
                    performJumpAction();
                }
                
                // Interact with E key
                if (key === 'e') {
                    performInteractAction();
                }
                
                // Left Control for attack
                if (event.key === 'Control') {
                    performAttackAction();
                }
                
                // Debug keyboard events
                console.log('Key pressed:', key);
            });
            
            document.addEventListener('keyup', (event) => {
                // Don't process any movement keys when typing in chat
                if (isChatActive && 
                   ['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 
                    ' ', 'space', 'control', 'e'].includes(event.key.toLowerCase())) {
                    return;
                }
                
                // Only stop propagation if needed for non-navigation keys
                if (!['Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    event.stopPropagation();
                }
                
                const key = event.key.toLowerCase();
                keysPressed[key] = false;
                
                // Additional key actions
                if (!isChatActive) {
                    // I key for inventory
                    if (key === 'i') {
                        toggleInventory();
                    }
                    
                    // C key for character screen
                    if (key === 'c') {
                        toggleCharacterScreen();
                    }
                    
                    // M key for map
                    if (key === 'm') {
                        toggleMap();
                    }
                    
                    // T key for character token
                    if (key === 't') {
                        showTokenDialog();
                    }
                    
                    // H key for help
                    if (key === 'h') {
                        toggleHelp();
                    }
                }
                
                // Debug keyboard events
                console.log('Key released:', key);
            });
            
            // Setup mouse controls
            renderer.domElement.addEventListener('click', (event) => {
                if (isChatActive || isModalOpen()) return;
                
                // Check if left mouse button
                if (event.button === 0) {
                    // Calculate mouse position in normalized device coordinates (-1 to +1)
                    const mouse = new THREE.Vector2(
                        (event.clientX / window.innerWidth) * 2 - 1,
                        -(event.clientY / window.innerHeight) * 2 + 1
                    );
                    
                    // Create raycaster
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Find intersections with the ground plane
                    const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const targetPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(groundPlane, targetPoint);
                    
                    // Check if Control key is pressed for attack
                    if (event.ctrlKey || keysPressed['control']) {
                        performAttackAction();
                    } else {
                        // Set target position
                        targetPosition = {
                            x: targetPoint.x,
                            y: playerMesh.position.y,
                            z: targetPoint.z
                        };
                        
                        // Turn player towards the clicked point immediately
                        const dx = targetPosition.x - playerMesh.position.x;
                        const dz = targetPosition.z - playerMesh.position.z;
                        if (Math.abs(dx) > 0.01 || Math.abs(dz) > 0.01) {
                            playerMesh.rotation.y = Math.atan2(dx, dz);
                        }
                        
                        // Visual feedback for click
                        const clickIndicator = document.createElement('div');
                        clickIndicator.textContent = '‚Ä¢';
                        clickIndicator.style.position = 'absolute';
                        clickIndicator.style.top = event.clientY + 'px';
                        clickIndicator.style.left = event.clientX + 'px';
                        clickIndicator.style.color = '#ffffff';
                        clickIndicator.style.fontSize = '24px';
                        clickIndicator.style.fontWeight = 'bold';
                        clickIndicator.style.transform = 'translate(-50%, -50%)';
                        clickIndicator.style.pointerEvents = 'none';
                        clickIndicator.style.zIndex = '100';
                        clickIndicator.style.opacity = '1';
                        document.body.appendChild(clickIndicator);
                        
                        // Fade out and remove
                        let opacity = 1;
                        const fadeInterval = setInterval(() => {
                            opacity -= 0.1;
                            clickIndicator.style.opacity = opacity;
                            if (opacity <= 0) {
                                clearInterval(fadeInterval);
                                document.body.removeChild(clickIndicator);
                            }
                        }, 50);
                    }
                }
            });
            
            // Setup UI element event listeners
            setupUIListeners();
            
            // Function to perform jump action
            function performJumpAction() {
                if (isJumping) return;
                
                isJumping = true;
                const originalY = playerMesh.position.y;
                const jumpHeight = 1.5;
                const jumpDuration = 0.5; // in seconds
                const jumpStart = gameState.gameTime;
                
                function animateJump() {
                    const elapsed = gameState.gameTime - jumpStart;
                    const progress = Math.min(elapsed / jumpDuration, 1);
                    
                    // Simple parabolic jump trajectory
                    const height = jumpHeight * Math.sin(progress * Math.PI);
                    playerMesh.position.y = originalY + height;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateJump);
                    } else {
                        // Reset position and jump state
                        playerMesh.position.y = originalY;
                        isJumping = false;
                    }
                }
                
                animateJump();
            }
            
            // Function to perform attack action
            function performAttackAction() {
                // Visual feedback for attack
                const attackIndicator = document.createElement('div');
                attackIndicator.textContent = '‚öîÔ∏è Attack!';
                attackIndicator.style.position = 'absolute';
                attackIndicator.style.top = '50%';
                attackIndicator.style.left = '50%';
                attackIndicator.style.transform = 'translate(-50%, -50%)';
                attackIndicator.style.color = '#ff3333';
                attackIndicator.style.fontSize = '24px';
                attackIndicator.style.fontWeight = 'bold';
                attackIndicator.style.textShadow = '0 0 5px #000';
                attackIndicator.style.pointerEvents = 'none';
                attackIndicator.style.zIndex = '100';
                document.body.appendChild(attackIndicator);
                
                // Remove after short duration
                setTimeout(() => {
                    document.body.removeChild(attackIndicator);
                }, 500);
                
                // TODO: Implement actual attack logic
                console.log('Attack action performed');
            }
            
            // Function to perform interact action
            function performInteractAction() {
                // Visual feedback for interaction
                const interactIndicator = document.createElement('div');
                interactIndicator.textContent = 'üëã Interact';
                interactIndicator.style.position = 'absolute';
                interactIndicator.style.top = '50%';
                interactIndicator.style.left = '50%';
                interactIndicator.style.transform = 'translate(-50%, -50%)';
                interactIndicator.style.color = '#33cc33';
                interactIndicator.style.fontSize = '24px';
                interactIndicator.style.fontWeight = 'bold';
                interactIndicator.style.textShadow = '0 0 5px #000';
                interactIndicator.style.pointerEvents = 'none';
                interactIndicator.style.zIndex = '100';
                document.body.appendChild(interactIndicator);
                
                // Remove after short duration
                setTimeout(() => {
                    document.body.removeChild(interactIndicator);
                }, 500);
                
                // TODO: Implement actual interact logic
                console.log('Interact action performed');
            }
            
            // Setup mobile controls
            setupMobileControls();
            
            // Movement and controls update in animation loop
            controls = {
                keysPressed: keysPressed,
                isChatActive: function() { return isChatActive; },
                moveDirection: new THREE.Vector3(),
                speed: CONFIG.MOVEMENT_SPEED,
                
                update: function(delta) {
                    // Skip movement if chat is active or any modal is open
                    if (this.isChatActive() || isModalOpen()) {
                        // Debug when movement is skipped
                        console.log('Movement skipped - Chat active:', this.isChatActive(), 'Modal open:', isModalOpen());
                        return;
                    }
                    
                    const moveDirection = new THREE.Vector3();
                    
                    // Handle keyboard movement
                    if (this.keysPressed['w'] || this.keysPressed['arrowup']) moveDirection.z -= 1;
                    if (this.keysPressed['s'] || this.keysPressed['arrowdown']) moveDirection.z += 1;
                    if (this.keysPressed['a'] || this.keysPressed['arrowleft']) moveDirection.x -= 1;
                    if (this.keysPressed['d'] || this.keysPressed['arrowright']) moveDirection.x += 1;
                    
                    // Debug log if we have keyboard input
                    if (this.keysPressed['w'] || this.keysPressed['arrowup'] || 
                        this.keysPressed['s'] || this.keysPressed['arrowdown'] || 
                        this.keysPressed['a'] || this.keysPressed['arrowleft'] || 
                        this.keysPressed['d'] || this.keysPressed['arrowright']) {
                        console.log('Keyboard input detected:', 
                                   'W:', this.keysPressed['w'], 
                                   'A:', this.keysPressed['a'], 
                                   'S:', this.keysPressed['s'], 
                                   'D:', this.keysPressed['d'],
                                   'Arrows:', this.keysPressed['arrowup'], this.keysPressed['arrowdown'], 
                                   this.keysPressed['arrowleft'], this.keysPressed['arrowright']);
                    }
                    
                    // If we have input from the virtual joystick, use it instead
                    // Only override if there's actual joystick movement
                    if (this.moveDirection.length() > 0) {
                        // On mobile, prefer the joystick input over keyboard
                        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                            moveDirection.copy(this.moveDirection);
                        } 
                        // On desktop, combine with keyboard input (keyboard takes priority if both are used)
                        else if (moveDirection.length() === 0) {
                            moveDirection.copy(this.moveDirection);
                        }
                    }
                    
                    // Handle target position movement (from mouse clicks)
                    if (targetPosition) {
                        const dx = targetPosition.x - playerMesh.position.x;
                        const dz = targetPosition.z - playerMesh.position.z;
                        const distSquared = dx * dx + dz * dz;
                        
                        // If we're close enough to the target, stop moving
                        if (distSquared < 0.1) {
                            targetPosition = null;
                        } else {
                            // Calculate normalized direction to target
                            const dist = Math.sqrt(distSquared);
                            moveDirection.x = dx / dist;
                            moveDirection.z = dz / dist;
                        }
                    }
                    
                    if (moveDirection.length() > 0) {
                        moveDirection.normalize();
                        
                        // Calculate new position
                        const newPosition = {
                            x: playerMesh.position.x + moveDirection.x * this.speed * delta,
                            y: playerMesh.position.y,
                            z: playerMesh.position.z + moveDirection.z * this.speed * delta
                        };
                        
                        // Check for collision and get valid position
                        const validPosition = collisionSystem.getValidPosition(
                            {x: playerMesh.position.x, y: playerMesh.position.y, z: playerMesh.position.z},
                            newPosition,
                            0.4 // Player radius
                        );
                        
                        // Move the player
                        playerMesh.position.x = validPosition.x;
                        playerMesh.position.z = validPosition.z;
                        
                        // Update player direction
                        if (moveDirection.x !== 0 || moveDirection.z !== 0) {
                            playerMesh.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                        }
                        
                        // Update camera position
                        camera.position.x = playerMesh.position.x;
                        camera.position.z = playerMesh.position.z + 8;
                        camera.lookAt(playerMesh.position);
                        
                        // Update game state
                        gameState.player.position = {
                            x: playerMesh.position.x,
                            y: playerMesh.position.y,
                            z: playerMesh.position.z
                        };
                        
                        // Send position update to server
                        sendPositionUpdate();
                    }
                }
            };
        }
        
        // Setup UI event listeners
        function setupUIListeners() {
            // Character screen
            const characterScreen = document.getElementById('character-screen');
            const statClose = document.querySelector('.stat-close');
            
            statClose.addEventListener('click', () => {
                hideElement(characterScreen);
            });
            
            // Map screen
            const mapScreen = document.getElementById('map-screen');
            const mapClose = document.querySelector('.map-close');
            
            mapClose.addEventListener('click', () => {
                hideElement(mapScreen);
            });
            
            // Inventory close button
            const closeInventory = document.getElementById('close-inventory');
            closeInventory.addEventListener('click', () => {
                hideElement(inventory);
            });
            
            // Help screen
            const keyBindings = document.getElementById('key-bindings');
            const helpCloseBtn = keyBindings.querySelector('.close-button');
            
            helpCloseBtn.addEventListener('click', () => {
                hideElement(keyBindings);
            });
            
            // Allow player list to toggle on click/tap in desktop mode
            playerList.addEventListener('click', () => {
                playerList.classList.toggle('expanded');
            });
        }
        
        // Check if any modal window is open
        function isModalOpen() {
            const modalElements = [
                document.getElementById('character-screen'),
                document.getElementById('map-screen'),
                document.getElementById('inventory'),
                document.getElementById('player-modal'),
                document.getElementById('reconnect-token'),
                document.getElementById('key-bindings'),
                document.getElementById('character-creation')
            ];
            
            return modalElements.some(elem => {
                // Element is visible if it doesn't have the 'hidden' class AND
                // either has no display style or display is not 'none'
                return elem && 
                       !elem.classList.contains('hidden') && 
                       (elem.style.display === '' || elem.style.display !== 'none');
            });
        }
        
        // Toggle inventory visibility
        function toggleInventory() {
            const inventoryEl = document.getElementById('inventory');
            inventoryEl.classList.toggle('hidden');
            
            if (!inventoryEl.classList.contains('hidden')) {
                inventoryEl.style.display = 'block';
            } else {
                inventoryEl.style.display = 'none';
            }
        }
        
        // Toggle character screen visibility
        function toggleCharacterScreen() {
            const characterScreen = document.getElementById('character-screen');
            characterScreen.classList.toggle('hidden');
            
            if (!characterScreen.classList.contains('hidden')) {
                characterScreen.style.display = 'block';
            } else {
                characterScreen.style.display = 'none';
            }
        }
        
        // Update character stats in the character screen
        function updateCharacterStats() {
            if (!gameState.player) return;
            
            document.getElementById('stat-name').textContent = gameState.player.name || '-';
            document.getElementById('stat-class').textContent = gameState.player.class || '-';
            document.getElementById('stat-level').textContent = gameState.player.level || '1';
            document.getElementById('stat-exp').textContent = `${gameState.player.experience || 0}/100`;
            document.getElementById('stat-health').textContent = `${gameState.player.health || 100}/${gameState.player.maxHealth || 100}`;
            document.getElementById('stat-mana').textContent = `${gameState.player.mana || 50}/${gameState.player.maxMana || 50}`;
            
            // Default values for stats if not present
            document.getElementById('stat-str').textContent = gameState.player.strength || '10';
            document.getElementById('stat-dex').textContent = gameState.player.dexterity || '10';
            document.getElementById('stat-int').textContent = gameState.player.intelligence || '10';
            document.getElementById('stat-vit').textContent = gameState.player.vitality || '10';
            document.getElementById('stat-atk').textContent = gameState.player.attackPower || '15';
            document.getElementById('stat-def').textContent = gameState.player.defense || '5';
            document.getElementById('stat-mag').textContent = gameState.player.magicPower || '10';
            
            // Format creation date
            const created = gameState.player.created ? new Date(gameState.player.created).toLocaleString() : '-';
            document.getElementById('stat-created').textContent = created;
        }
        
        // Toggle map visibility
        function toggleMap() {
            const mapScreen = document.getElementById('map-screen');
            mapScreen.classList.toggle('hidden');
            
            if (!mapScreen.classList.contains('hidden')) {
                mapScreen.style.display = 'block';
                
                // Refresh map if needed
                drawMap();
            } else {
                mapScreen.style.display = 'none';
            }
        }
        
        // Draw world map
        function drawMap() {
            const canvas = document.getElementById('map-canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas dimensions
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            // Clear the canvas
            ctx.fillStyle = '#243447';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#334455';
            ctx.lineWidth = 1;
            
            const gridSize = 20;
            const gridCount = Math.ceil(CONFIG.WORLD_SIZE / gridSize);
            
            // Calculate scaling factor
            const scale = Math.min(canvas.width, canvas.height) / CONFIG.WORLD_SIZE;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw grid lines
            ctx.beginPath();
            for (let i = -gridCount; i <= gridCount; i++) {
                const pos = i * gridSize * scale;
                
                // Vertical lines
                ctx.moveTo(centerX + pos, 0);
                ctx.lineTo(centerX + pos, canvas.height);
                
                // Horizontal lines
                ctx.moveTo(0, centerY + pos);
                ctx.lineTo(canvas.width, centerY + pos);
            }
            ctx.stroke();
            
            // Draw obstacles (trees, rocks, houses)
            collisionSystem.obstacles.forEach(obstacle => {
                const x = centerX + obstacle.position.x * scale;
                const y = centerY + obstacle.position.z * scale;
                
                ctx.beginPath();
                
                if (obstacle.type === 'tree') {
                    ctx.fillStyle = '#2D572C';
                    ctx.arc(x, y, obstacle.radius * scale, 0, Math.PI * 2);
                } else if (obstacle.type === 'rock') {
                    ctx.fillStyle = '#888888';
                    ctx.arc(x, y, obstacle.radius * scale, 0, Math.PI * 2);
                } else if (obstacle.type === 'house') {
                    ctx.fillStyle = '#DDCCAA';
                    const size = obstacle.radius * 1.5 * scale;
                    ctx.rect(x - size/2, y - size/2, size, size);
                }
                
                ctx.fill();
            });
            
            // Draw player position
            if (gameState.player && playerMesh) {
                const playerX = centerX + playerMesh.position.x * scale;
                const playerY = centerY + playerMesh.position.z * scale;
                
                // Draw player position marker
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.arc(playerX, playerY, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw player direction
                const dirLength = 10;
                const dirX = Math.sin(playerMesh.rotation.y) * dirLength;
                const dirY = Math.cos(playerMesh.rotation.y) * dirLength;
                
                ctx.strokeStyle = '#ffcc00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(playerX, playerY);
                ctx.lineTo(playerX + dirX, playerY + dirY);
                ctx.stroke();
            }
            
            // Draw other players
            for (const id in gameState.otherPlayers) {
                const player = gameState.otherPlayers[id];
                if (player.mesh) {
                    const otherX = centerX + player.mesh.position.x * scale;
                    const otherY = centerY + player.mesh.position.z * scale;
                    
                    ctx.fillStyle = '#33ccff';
                    ctx.beginPath();
                    ctx.arc(otherX, otherY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw legend
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 120, 100);
            
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(20, 25, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.fillText('You', 35, 30);
            
            ctx.fillStyle = '#33ccff';
            ctx.beginPath();
            ctx.arc(20, 45, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillText('Other Players', 35, 50);
            
            ctx.fillStyle = '#2D572C';
            ctx.beginPath();
            ctx.arc(20, 65, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillText('Trees', 35, 70);
            
            ctx.fillStyle = '#888888';
            ctx.beginPath();
            ctx.arc(20, 85, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.fillText('Rocks', 35, 90);
        }
        
        // Toggle help visibility
        function toggleHelp() {
            const keyBindings = document.getElementById('key-bindings');
            keyBindings.classList.toggle('hidden');
            
            // If opened, ensure it's visible
            if (!keyBindings.classList.contains('hidden')) {
                keyBindings.style.display = 'block';
            } else {
                keyBindings.style.display = 'none';
            }
        }
        
        // Toggle chat visibility
        function toggleChat() {
            chatUI.classList.toggle('hidden');
            if (!chatUI.classList.contains('hidden')) {
                chatInput.focus();
            }
        }
        
        // Setup mobile controls
        function setupMobileControls() {
            // Show mobile controls on touch devices
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            if (isTouchDevice) {
                const mobileControls = document.getElementById('mobile-controls');
                showElement(mobileControls);
                
                // Setup virtual joystick
                setupVirtualJoystick();
                
                // Setup action buttons
                const btnAttack = document.getElementById('btn-attack');
                const btnJump = document.getElementById('btn-jump');
                const btnInteract = document.getElementById('btn-interact');
                const btnChat = document.getElementById('btn-chat');
                const btnInventory = document.getElementById('btn-inventory');
                const btnPlayers = document.getElementById('btn-players');
                const btnCharacter = document.getElementById('btn-character');
                const btnMap = document.getElementById('btn-map');
                const btnHelp = document.getElementById('btn-help');
                
                // Attack button
                btnAttack.addEventListener('touchstart', () => {
                    console.log('Attack button pressed');
                    performAttackAction();
                });
                
                // Jump button
                btnJump.addEventListener('touchstart', () => {
                    console.log('Jump button pressed');
                    performJumpAction();
                });
                
                // Interact button
                btnInteract.addEventListener('touchstart', () => {
                    console.log('Interact button pressed');
                    performInteractAction();
                });
                
                // Chat button
                btnChat.addEventListener('touchend', () => {
                    toggleChat();
                });
                
                // Inventory button
                btnInventory.addEventListener('touchend', () => {
                    toggleInventory();
                });
                
                // Character button
                btnCharacter.addEventListener('touchend', () => {
                    toggleCharacterScreen();
                });
                
                // Map button
                btnMap.addEventListener('touchend', () => {
                    toggleMap();
                });
                
                // Help button
                btnHelp.addEventListener('touchend', () => {
                    toggleHelp();
                });
                
                // Players button (show player modal)
                btnPlayers.addEventListener('touchend', () => {
                    togglePlayerModal();
                });
                
                // Hide chat and inventory by default on mobile
                hideElement(chatUI);
                hideElement(inventory);
                
                // Set up player modal close button
                document.querySelector('#player-modal .close-button').addEventListener('click', () => {
                    hidePlayerModal();
                });
                
                // Make modals draggable on mobile for better positioning
                makeElementDraggable(document.getElementById('character-screen'));
                makeElementDraggable(document.getElementById('map-screen'));
                makeElementDraggable(document.getElementById('key-bindings'));
                makeElementDraggable(document.getElementById('player-modal'));
                makeElementDraggable(inventory);
            }
        }
        
        // Setup virtual joystick for mobile controls
        function setupVirtualJoystick() {
            const joystickContainer = document.getElementById('joystick-container');
            const joystickHandle = document.getElementById('joystick-handle');
            
            if (!joystickContainer || !joystickHandle) return;
            
            let active = false;
            let startX = 0;
            let startY = 0;
            let joystickX = 0;
            let joystickY = 0;
            
            // Container dimensions
            const containerRect = joystickContainer.getBoundingClientRect();
            const containerCenterX = containerRect.width / 2;
            const containerCenterY = containerRect.height / 2;
            const maxDistance = containerRect.width / 2 - 10;
            
            // Touch start
            joystickContainer.addEventListener('touchstart', function(e) {
                e.preventDefault();
                active = true;
                
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                
                // Center handle initially
                joystickHandle.style.transform = 'translate(-50%, -50%)';
            });
            
            // Touch move
            document.addEventListener('touchmove', function(e) {
                if (!active) return;
                
                e.preventDefault();
                
                // Calculate joystick position
                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                
                // Distance from start
                let deltaX = touchX - startX;
                let deltaY = touchY - startY;
                
                // Limit to container radius
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * maxDistance;
                    deltaY = Math.sin(angle) * maxDistance;
                }
                
                // Update handle position
                joystickHandle.style.left = (containerCenterX + deltaX) + 'px';
                joystickHandle.style.top = (containerCenterY + deltaY) + 'px';
                
                // Normalize for movement (-1 to 1)
                joystickX = deltaX / maxDistance;
                joystickY = deltaY / maxDistance;
                
                // Update controls
                if (controls) {
                    // Calculate movement direction from joystick
                    // Note: We reverse X for sidesteps and Z for forward/back
                    controls.moveDirection.x = joystickX;
                    controls.moveDirection.z = joystickY;
                }
            }, { passive: false });
            
            // Touch end
            document.addEventListener('touchend', function(e) {
                if (!active) return;
                
                active = false;
                
                // Reset handle position
                joystickHandle.style.left = '50%';
                joystickHandle.style.top = '50%';
                joystickHandle.style.transform = 'translate(-50%, -50%)';
                
                // Reset joystick values
                joystickX = 0;
                joystickY = 0;
                
                // Update controls
                if (controls) {
                    controls.moveDirection.x = 0;
                    controls.moveDirection.z = 0;
                }
            }, { passive: false });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            gameState.gameTime += delta;
            
            // Only update if player is logged in
            if (isLoggedIn && playerMesh) {
                // Update controls
                if (controls) {
                    controls.update(delta);
                }
                
                // Send position updates to server at a reasonable interval (every 100ms)
                if (gameState.gameTime - lastPositionUpdateTime > 0.1) {
                    sendPositionUpdate();
                    lastPositionUpdateTime = gameState.gameTime;
                }
                
                // Render the scene
                renderer.render(scene, camera);
            }
        }
        
        // Initialize game variables
        let lastPositionUpdateTime = 0;

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Create a new character
        function createNewCharacter() {
            const name = document.getElementById('character-name').value.trim();
            const characterClass = document.getElementById('character-class').value;
            
            if (!name) {
                alert('Please enter a character name');
                return;
            }
            
            // Create new character
            gameState.player = {
                id: generateUUID(),
                name: name,
                class: characterClass,
                level: 1,
                experience: 0,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                inventory: [],
                position: { x: 0, y: 0, z: 0 },
                created: new Date().toISOString()
            };
            
            // Save character to localStorage
            saveCharacter();
            
            // Update UI
            document.getElementById('char-name').textContent = gameState.player.name;
            document.getElementById('char-level').textContent = gameState.player.level;
            updateHealthMana();
            
            // Hide character creation and show game UI
            hideElement(characterCreation);
            showGameUI();
            
            // Initialize game world
            initGameWorld();
            
            // Connect to server
            connectToServer();
            
            // Show character token
            showTokenDialog();
        }

        // Import character from token
        function importCharacter() {
            const tokenInput = document.getElementById('token-input').value.trim();
            
            if (!tokenInput) {
                alert('Please enter a valid character token');
                return;
            }
            
            try {
                const decodedToken = atob(tokenInput);
                const characterData = JSON.parse(decodedToken);
                
                // Validate character data
                if (!characterData.id || !characterData.name || !characterData.class) {
                    throw new Error('Invalid character data');
                }
                
                // Set as current character
                gameState.player = characterData;
                
                // Save to localStorage
                saveCharacter();
                
                // Update UI
                document.getElementById('char-name').textContent = gameState.player.name;
                document.getElementById('char-level').textContent = gameState.player.level;
                updateHealthMana();
                
                // Hide character creation and show game UI
                hideElement(characterCreation);
                showGameUI();
                
                // Initialize game world
                initGameWorld();
                
                // Connect to server
                connectToServer();
                
                addSystemMessage('Character imported successfully!');
            } catch (e) {
                console.error('Error importing character', e);
                alert('Invalid character token. Please try again.');
            }
        }

        // Show the character token dialog
        function showTokenDialog() {
            if (isLoggedIn && gameState.player) {
                const tokenModal = document.getElementById('reconnect-token');
                const tokenText = document.getElementById('token-text');
                tokenText.textContent = gameState.player.token;
                showElement(tokenModal);
            }
        }

        // Copy token to clipboard
        function copyTokenToClipboard() {
            const tokenText = document.getElementById('token-text').textContent;
            navigator.clipboard.writeText(tokenText)
                .then(() => {
                    alert('Token copied to clipboard!');
                })
                .catch(err => {
                    console.error('Error copying token', err);
                    alert('Failed to copy token. Please select and copy it manually.');
                });
        }

        // Debug logging
        function debugLog(message, data) {
            if (CONFIG.DEBUG) {
                console.log(`[DEBUG] ${message}`, data);
            }
        }

        // Connect to WebSocket server
        function connectToServer() {
            showLoadingIndicator('Connecting to server...');
            updateConnectionStatus('connecting', 'Connecting to server...');
            
            debugLog('Attempting to connect to', CONFIG.WEBSOCKET_URL);
            
            // Create WebSocket connection
            websocket = new WebSocket(CONFIG.WEBSOCKET_URL);
            
            websocket.onopen = function() {
                debugLog('Connected to server');
                hideLoadingIndicator();
                updateConnectionStatus('connected', 'Connected');
                
                // Send initial player data
                const initialData = {
                    type: 'player_join',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        class: gameState.player.class,
                        position: gameState.player.position,
                        level: gameState.player.level,
                        health: gameState.player.health,
                        maxHealth: gameState.player.maxHealth
                    }
                };
                
                debugLog('Sending player_join', initialData);
                websocket.send(JSON.stringify(initialData));
                addSystemMessage('Connected to server. Welcome to Pixel Kingdom!');
            };
            
            websocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    debugLog('Received message', data);
                    handleServerMessage(data);
                } catch (err) {
                    debugLog('Error parsing message', err);
                    console.error('Error parsing message:', err, event.data);
                }
            };
            
            websocket.onclose = function(event) {
                debugLog('Disconnected from server', event.code + ': ' + event.reason);
                updateConnectionStatus('disconnected', 'Disconnected. Reconnecting...');
                addSystemMessage('Disconnected from server. Attempting to reconnect...');
                
                // Try to reconnect after a delay
                setTimeout(connectToServer, 3000);
            };
            
            websocket.onerror = function(error) {
                debugLog('WebSocket error', error);
                console.error('WebSocket error:', error);
                hideLoadingIndicator();
                updateConnectionStatus('disconnected', 'Connection error');
                addSystemMessage('Connection error. Please try again later.');
            };
        }
        
        // Update connection status display
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connection-status');
            
            // Remove all status classes
            statusElement.classList.remove('connecting', 'connected', 'disconnected');
            
            // Add the current status class
            statusElement.classList.add(status);
            
            // Set the status message
            statusElement.textContent = message;
            
            // Auto-hide the status after 3 seconds if connected
            if (status === 'connected') {
                setTimeout(() => {
                    statusElement.style.opacity = '0';
                }, 3000);
            } else {
                statusElement.style.opacity = '1';
            }
        }

        // Handle messages from the server
        function handleServerMessage(data) {
            try {
                switch (data.type) {
                    case 'join_confirm':
                        debugLog('Join confirmed', data);
                        break;
                        
                    case 'player_join':
                        // Only process if it's not our own join message
                        if (data.player && data.player.id !== gameState.player.id) {
                            debugLog('Adding other player', data.player);
                            addOtherPlayer(data.player);
                            addSystemMessage(`${data.player.name} has joined the game!`);
                            updatePlayerList();
                        } else {
                            debugLog('Ignoring own player_join message');
                        }
                        break;
                        
                    case 'player_position':
                        // Update other player position
                        if (data.player && data.player.id !== gameState.player.id) {
                            debugLog('Updating player position', data.player);
                            updateOtherPlayerPosition(data.player);
                        }
                        break;
                        
                    case 'chat_message':
                        // Display chat message from other players
                        debugLog('Received chat message', data);
                        if (data.player && data.player.id !== gameState.player.id) {
                            addPlayerMessage(data.player.name, data.message);
                        }
                        break;
                        
                    case 'player_leave':
                        // Remove player who disconnected
                        debugLog('Player leaving', data);
                        if (data.playerId && gameState.otherPlayers[data.playerId]) {
                            removeOtherPlayer(data.playerId);
                            addSystemMessage(`${data.playerName} has left the game.`);
                            updatePlayerList();
                        }
                        break;
                        
                    case 'npc_info':
                        // Add NPC to the game
                        if (data.npc) {
                            addNpcToGame(data.npc);
                        }
                        break;
                        
                    case 'item_info':
                        // Add item to the game
                        if (data.item) {
                            addItemToGame(data.item);
                        }
                        break;
                        
                    default:
                        debugLog('Unknown message type', data.type);
                }
            } catch (e) {
                console.error('Error handling server message', e);
                debugLog('Error handling message', e.message);
            }
        }

        // Send position update to server
        function sendPositionUpdate() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const updateData = {
                    type: 'player_position',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        position: gameState.player.position
                    }
                };
                
                debugLog('Sending position update', updateData);
                websocket.send(JSON.stringify(updateData));
            } else {
                debugLog('Cannot send position update - WebSocket not open');
            }
        }

        // Send chat message
        function sendChatMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const chatData = {
                    type: 'chat_message',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name
                    },
                    message: message
                };
                
                debugLog('Sending chat message', chatData);
                websocket.send(JSON.stringify(chatData));
                addPlayerMessage(gameState.player.name, message);
            } else {
                debugLog('Cannot send chat message - WebSocket not open');
                addSystemMessage('You are not connected to the server.');
            }
        }

        // Add another player to the game
        function addOtherPlayer(playerData) {
            if (!playerData || !playerData.id) {
                debugLog('Invalid player data', playerData);
                return;
            }
            
            // Check if player already exists
            if (gameState.otherPlayers[playerData.id]) {
                debugLog('Player already exists, updating data', playerData);
                // Update player data
                gameState.otherPlayers[playerData.id].data = playerData;
                return;
            }
            
            debugLog('Creating new player mesh', playerData);
            
            // Create player mesh
            const otherPlayerMesh = createCharacterMesh(playerData.class);
            otherPlayerMesh.position.set(
                playerData.position.x,
                playerData.position.y,
                playerData.position.z
            );
            
            // Add name tag
            createPlayerNameTag(otherPlayerMesh, playerData.name);
            
            // Add to scene
            playerGroup.add(otherPlayerMesh);
            
            // Store player data
            gameState.otherPlayers[playerData.id] = {
                data: playerData,
                mesh: otherPlayerMesh
            };
            
            updatePlayerList();
            debugLog('Other player added successfully', playerData.id);
        }
        
        // Remove other player from the game
        function removeOtherPlayer(playerId) {
            const player = gameState.otherPlayers[playerId];
            if (player && player.mesh) {
                debugLog('Removing player from scene', playerId);
                playerGroup.remove(player.mesh);
                delete gameState.otherPlayers[playerId];
                addSystemMessage(`${player.data.name} has left the game.`);
            } else {
                debugLog('Failed to remove player - not found', playerId);
            }
        }

        // Update other player position
        function updateOtherPlayerPosition(playerData) {
            const player = gameState.otherPlayers[playerData.id];
            
            if (!player) {
                debugLog('Player not found for position update, adding them', playerData);
                addOtherPlayer(playerData);
                return;
            }
            
            if (player && player.mesh) {
                // Smoothly move to new position
                const targetPosition = new THREE.Vector3(
                    playerData.position.x,
                    playerData.position.y,
                    playerData.position.z
                );
                
                // Update player direction
                if (player.data.position) {
                    const prevX = player.data.position.x;
                    const prevZ = player.data.position.z;
                    
                    const moveX = playerData.position.x - prevX;
                    const moveZ = playerData.position.z - prevZ;
                    
                    if (Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01) {
                        player.mesh.rotation.y = Math.atan2(moveX, moveZ);
                    }
                }
                
                const currentPosition = player.mesh.position;
                currentPosition.lerp(targetPosition, 0.5);
                
                // Update stored data
                player.data.position = playerData.position;
            } else {
                debugLog('Player mesh not found for position update', playerData.id);
            }
        }
        
        // Add NPC to the game
        function addNpcToGame(npcData) {
            // Implementation will be added later
            console.log('NPC added:', npcData);
        }
        
        // Add item to the game
        function addItemToGame(itemData) {
            // Implementation will be added later
            console.log('Item added:', itemData);
        }

        // Update the player list UI
        function updatePlayerList() {
            // Update player count
            const playerCount = 1 + Object.keys(gameState.otherPlayers).length; // Current player + others
            document.getElementById('online-count').textContent = playerCount;
            document.getElementById('modal-online-count').textContent = playerCount;
            document.getElementById('btn-players-count').textContent = playerCount;
            
            // Update both player lists
            updatePlayerListContent('player-details');
            updatePlayerListContent('player-modal-list');
        }
        
        // Update a specific player list content
        function updatePlayerListContent(elementId) {
            // Clear the list
            const playerContainer = document.getElementById(elementId);
            playerContainer.innerHTML = '';
            
            // Add the current player
            const currentPlayerItem = document.createElement('div');
            currentPlayerItem.className = 'player-item';
            
            const currentPlayerName = document.createElement('div');
            currentPlayerName.className = 'player-name';
            currentPlayerName.textContent = `${gameState.player.name} (You)`;
            
            const currentPlayerInfo = document.createElement('div');
            currentPlayerInfo.className = 'player-info';
            
            const currentPlayerLevel = document.createElement('span');
            currentPlayerLevel.textContent = `Lvl ${gameState.player.level}`;
            
            const healthIndicator = document.createElement('div');
            healthIndicator.className = 'health-indicator';
            healthIndicator.style.backgroundColor = getHealthColor(gameState.player.health, gameState.player.maxHealth);
            
            currentPlayerInfo.appendChild(currentPlayerLevel);
            currentPlayerInfo.appendChild(healthIndicator);
            
            currentPlayerItem.appendChild(currentPlayerName);
            currentPlayerItem.appendChild(currentPlayerInfo);
            playerContainer.appendChild(currentPlayerItem);
            
            // Add other players
            const playerIds = Object.keys(gameState.otherPlayers);
            
            playerIds.forEach(id => {
                const player = gameState.otherPlayers[id];
                
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                const playerName = document.createElement('div');
                playerName.className = 'player-name';
                playerName.textContent = player.data.name;
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                
                const playerLevel = document.createElement('span');
                // Use level from player data if available, default to 1
                const level = player.data.level || 1;
                playerLevel.textContent = `Lvl ${level}`;
                
                const healthInd = document.createElement('div');
                healthInd.className = 'health-indicator';
                // Default to full health if not specified
                const health = player.data.health || 100;
                const maxHealth = player.data.maxHealth || 100;
                healthInd.style.backgroundColor = getHealthColor(health, maxHealth);
                
                playerInfo.appendChild(playerLevel);
                playerInfo.appendChild(healthInd);
                
                playerItem.appendChild(playerName);
                playerItem.appendChild(playerInfo);
                playerContainer.appendChild(playerItem);
            });
        }
        
        // Get color based on health percentage
        function getHealthColor(health, maxHealth) {
            const healthPercent = health / maxHealth;
            
            if (healthPercent > 0.7) {
                return '#33cc33'; // Green
            } else if (healthPercent > 0.3) {
                return '#ffcc00'; // Yellow
            } else {
                return '#cc3333'; // Red
            }
        }

        // Add system message to chat
        function addSystemMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-system';
            messageElement.textContent = `System: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Add player message to chat
        function addPlayerMessage(playerName, message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-player';
            messageElement.textContent = `${playerName}: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Save character to localStorage
        function saveCharacter() {
            localStorage.setItem('pixelRealmsCharacter', JSON.stringify(gameState.player));
        }

        // Update health and mana UI displays
        function updateHealthMana() {
            if (!gameState.player) return;
            
            // Update health bar
            const healthFill = document.getElementById('health-fill');
            const healthText = healthBar.querySelector('.progress-text');
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            
            healthFill.style.width = healthPercent + '%';
            healthFill.style.backgroundColor = getHealthColor(gameState.player.health, gameState.player.maxHealth);
            healthText.textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            
            // Update mana bar
            const manaFill = document.getElementById('mana-fill');
            const manaText = manaBar.querySelector('.progress-text');
            const manaPercent = (gameState.player.mana / gameState.player.maxMana) * 100;
            
            manaFill.style.width = manaPercent + '%';
            manaText.textContent = `${gameState.player.mana}/${gameState.player.maxMana}`;
        }

        // Show game UI elements
        function showGameUI() {
            showElement(statsUI);
            showElement(chatUI);
            showElement(playerList);
            showElement(healthBar);
            showElement(manaBar);
            showElement(inventory);
            
            // For mobile, completely hide the player list
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                hideElement(playerList);
            }
        }

        // Show element by removing hidden class
        function showElement(element) {
            element.classList.remove('hidden');
            
            // For modals and special UI elements that use display: none
            if (element.id === 'character-screen' || 
                element.id === 'map-screen' || 
                element.id === 'key-bindings' || 
                element.id === 'player-modal') {
                element.style.display = 'block';
            }
        }

        // Hide element by adding hidden class
        function hideElement(element) {
            element.classList.add('hidden');
            
            // For modals and special UI elements that use display: none
            if (element.id === 'character-screen' || 
                element.id === 'map-screen' || 
                element.id === 'key-bindings' || 
                element.id === 'player-modal') {
                element.style.display = 'none';
            }
        }

        // Show loading indicator
        function showLoadingIndicator(message) {
            const indicator = document.getElementById('loading-indicator');
            indicator.textContent = message || 'Loading...';
            indicator.classList.add('active');
        }

        // Hide loading indicator
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            indicator.classList.remove('active');
        }

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Show player modal dialog
        function showPlayerModal() {
            const playerModal = document.getElementById('player-modal');
            // Use classList to make it consistent with other UI elements
            showElement(playerModal);
            // Also make sure the element is visible since we're using display: none in CSS
            playerModal.style.display = 'block';
            updatePlayerList();
        }
        
        // Hide player modal dialog
        function hidePlayerModal() {
            const playerModal = document.getElementById('player-modal');
            playerModal.classList.add('hidden');
            playerModal.style.display = 'none';
        }

        // Make an element draggable on touch devices
        function makeElementDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            if (element.querySelector('.modal-header')) {
                // If present, the header is where you move the element from
                element.querySelector('.modal-header').onmousedown = dragMouseDown;
                element.querySelector('.modal-header').ontouchstart = dragTouchStart;
            } else {
                // Otherwise, move the element from anywhere inside the element
                element.onmousedown = dragMouseDown;
                element.ontouchstart = dragTouchStart;
            }
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // Call a function whenever the cursor moves
                document.onmousemove = elementDrag;
            }
            
            function dragTouchStart(e) {
                e = e || window.event;
                e.preventDefault();
                // Get the touch position at startup
                pos3 = e.touches[0].clientX;
                pos4 = e.touches[0].clientY;
                document.ontouchend = closeDragElement;
                // Call a function whenever the finger moves
                document.ontouchmove = elementTouchDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                // Calculate the new cursor position
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                // Set the element's new position
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function elementTouchDrag(e) {
                e = e || window.event;
                e.preventDefault();
                // Calculate the new touch position
                pos1 = pos3 - e.touches[0].clientX;
                pos2 = pos4 - e.touches[0].clientY;
                pos3 = e.touches[0].clientX;
                pos4 = e.touches[0].clientY;
                // Set the element's new position
                element.style.top = (element.offsetTop - pos2) + "px";
                element.style.left = (element.offsetLeft - pos1) + "px";
            }
            
            function closeDragElement() {
                // Stop moving when mouse/touch is released
                document.onmouseup = null;
                document.onmousemove = null;
                document.ontouchend = null;
                document.ontouchmove = null;
            }
        }

        // Toggle player modal visibility
        function togglePlayerModal() {
            const playerModal = document.getElementById('player-modal');
            playerModal.classList.toggle('hidden');
            
            if (!playerModal.classList.contains('hidden')) {
                playerModal.style.display = 'block';
                updatePlayerList();
            } else {
                playerModal.style.display = 'none';
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>
