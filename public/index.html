<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Kingdom - Lightweight MMORPG</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #111;
            color: #eee;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
        }
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #character-creation {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            pointer-events: auto;
            border: 2px solid #555;
        }
        .hidden {
            display: none !important;
        }
        input, select, button {
            display: block;
            margin: 10px auto;
            padding: 8px;
            width: 80%;
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
            font-size: 16px; /* Larger for mobile */
        }
        button {
            background-color: #553388;
            cursor: pointer;
            transition: background-color 0.2s;
            padding: 12px 8px;
        }
        button:hover {
            background-color: #6644aa;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            z-index: 10;
        }
        #chat {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 350px;
            max-width: calc(100% - 220px);
            height: 180px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            pointer-events: auto;
            z-index: 10;
        }
        #chat-messages {
            height: 150px;
            overflow-y: auto;
            padding: 5px;
            font-size: 14px;
        }
        #chat-input {
            position: absolute;
            bottom: 5px;
            left: 5px;
            width: calc(100% - 20px);
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            color: #eee;
            border-radius: 3px;
        }
        .chat-message {
            margin-bottom: 3px;
            word-wrap: break-word;
        }
        .chat-system { color: #aaccff; }
        .chat-player { color: #aaffcc; }
        .chat-whisper { color: #ffaacc; }
        #player-list {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            min-width: 100px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 10;
        }
        #online-count {
            text-align: center;
            font-weight: bold;
        }
        #player-details {
            display: none;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        #player-list.expanded #player-details {
            display: block;
        }
        .player-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 3px;
            border-bottom: 1px solid #444;
        }
        .player-name {
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-info {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .health-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #cc3333;
        }
        #inventory {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 5px;
            width: 200px;
            height: 150px;
            z-index: 10;
        }
        .inventory-slot {
            display: inline-block;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 1px solid #555;
            margin: 2px;
        }
        #health-bar {
            position: absolute;
            top: 50px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #cc3333;
        }
        #mana-bar {
            position: absolute;
            top: 70px;
            left: 10px;
            width: 150px;
            height: 15px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #mana-fill {
            height: 100%;
            width: 100%;
            background-color: #3366cc;
        }
        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-size: 12px;
            line-height: 15px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.8);
        }
        #reconnect-token {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 5px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            pointer-events: auto;
            border: 2px solid #555;
            z-index: 20;
        }
        #token-text {
            word-break: break-all;
            background-color: #1a1a1a;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
        }
        .loading-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            transition: opacity 0.3s;
            opacity: 0;
            z-index: 20;
        }
        .loading-indicator.active {
            opacity: 1;
        }
        
        /* Mobile controls */
        #mobile-controls {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 10;
        }
        .control-button {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #555;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 5px;
            user-select: none;
            touch-action: manipulation;
        }
        #dpad {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
        }
        #btn-up { grid-area: 1/2/2/3; }
        #btn-left { grid-area: 2/1/3/2; }
        #btn-right { grid-area: 2/3/3/4; }
        #btn-down { grid-area: 3/2/4/3; }
        
        /* Tab key indicator */
        #tab-indicator {
            position: absolute;
            top: 10px;
            right: 120px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 3px;
            display: none;
            z-index: 10;
        }
        
        /* Media Queries for Mobile */
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
                gap: 20px;
            }
            #chat {
                max-width: calc(100% - 20px);
                width: auto;
                height: 120px;
            }
            #chat-messages {
                height: 90px;
            }
            #health-bar, #mana-bar {
                width: 100px;
            }
            #inventory {
                width: 150px;
                height: 100px;
            }
            .inventory-slot {
                width: 30px;
                height: 30px;
            }
            #tab-indicator {
                display: block;
            }
        }

        /* Add CSS for connection status indicator */
        .connection-status {
            position: fixed;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: #ffcc00;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        .connection-status.connected {
            color: #33cc33;
            opacity: 0;
        }
        .connection-status.disconnected {
            color: #cc3333;
        }
        .connection-status.connecting {
            color: #ffcc00;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- ThreeJS will render here -->
    </div>

    <div id="ui-overlay">
        <div id="character-creation">
            <h2>Welcome to Pixel Kingdom</h2>
            <p>Create your character to begin exploring</p>
            <input type="text" id="character-name" placeholder="Choose your character name" maxlength="20">
            <select id="character-class">
                <option value="warrior">Warrior</option>
                <option value="mage">Mage</option>
                <option value="ranger">Ranger</option>
            </select>
            <div>
                <button id="start-new">Start Adventure</button>
                <button id="show-token-input">Import Character</button>
            </div>
            <div id="token-import" class="hidden">
                <input type="text" id="token-input" placeholder="Paste your character token here">
                <button id="import-token">Import</button>
            </div>
        </div>

        <div id="reconnect-token" class="hidden">
            <h2>Your Character Token</h2>
            <p>Save this token to transfer your character to another device:</p>
            <div id="token-text"></div>
            <button id="copy-token">Copy Token</button>
            <button id="close-token">Close</button>
        </div>

        <div id="stats" class="hidden">
            <div id="character-info">Name: <span id="char-name"></span> | Level: <span id="char-level">1</span></div>
        </div>

        <div id="player-list" class="hidden">
            <h3>Players Online: <span id="online-count">1</span></h3>
            <div id="player-details"></div>
        </div>

        <div id="health-bar" class="hidden">
            <div id="health-fill"></div>
            <div class="progress-text">100/100</div>
        </div>

        <div id="mana-bar" class="hidden">
            <div id="mana-fill"></div>
            <div class="progress-text">50/50</div>
        </div>

        <div id="inventory" class="hidden">
            <h3>Inventory</h3>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
            <div class="inventory-slot"></div>
        </div>

        <div id="chat" class="hidden">
            <div id="chat-messages"></div>
            <input type="text" id="chat-input" placeholder="Press Enter to chat...">
        </div>

        <div id="loading-indicator" class="loading-indicator">Loading resources...</div>
        
        <div id="mobile-controls" class="hidden">
            <div id="dpad">
                <div id="btn-up" class="control-button">⬆️</div>
                <div id="btn-left" class="control-button">⬅️</div>
                <div id="btn-right" class="control-button">➡️</div>
                <div id="btn-down" class="control-button">⬇️</div>
            </div>
            <div id="action-buttons">
                <div id="btn-chat" class="control-button">💬</div>
                <div id="btn-inventory" class="control-button">🎒</div>
            </div>
        </div>
        
        <div id="tab-indicator">Press Tab to show players</div>
    </div>

    <div id="connection-status" class="connection-status">Connecting...</div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';
        
        // Game configuration
        const CONFIG = {
            WORLD_SIZE: 100,
            TILE_SIZE: 1,
            MOVEMENT_SPEED: 5,
            WEBSOCKET_URL: location.protocol === 'https:' 
                ? 'wss://' + location.host + '/ws' 
                : 'ws://' + location.host + '/ws',
            SAVE_INTERVAL: 30000, // Save character every 30 seconds
        };

        // Game state
        let gameState = {
            player: null,
            otherPlayers: {},
            worldChunks: {},
            loadedChunks: new Set(),
            itemsInWorld: [],
            npcs: [],
            gameTime: 0,
            lastSaveTime: 0
        };

        // Main game components
        let scene, camera, renderer, clock;
        let controls, playerMesh, worldGroup, itemsGroup, playerGroup;
        let websocket;
        let isLoggedIn = false;

        // UI elements
        const characterCreation = document.getElementById('character-creation');
        const reconnectToken = document.getElementById('reconnect-token');
        const statsUI = document.getElementById('stats');
        const chatUI = document.getElementById('chat');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const playerList = document.getElementById('player-list');
        const onlinePlayers = document.getElementById('online-players');
        const healthBar = document.getElementById('health-bar');
        const manaBar = document.getElementById('mana-bar');
        const inventory = document.getElementById('inventory');
        const loadingIndicator = document.getElementById('loading-indicator');

        // Initialize the game
        function init() {
            // Check if there's a saved character
            const savedCharacter = localStorage.getItem('pixelRealmsCharacter');
            if (savedCharacter) {
                try {
                    gameState.player = JSON.parse(savedCharacter);
                    document.getElementById('char-name').textContent = gameState.player.name;
                    document.getElementById('char-level').textContent = gameState.player.level;
                    updateHealthMana();
                    hideElement(characterCreation);
                    showGameUI();
                    initGameWorld();
                    connectToServer();
                    isLoggedIn = true;
                } catch (e) {
                    console.error('Error loading saved character', e);
                    // If loading fails, we'll just show character creation
                }
            }
            
            // Set up event listeners for character creation
            document.getElementById('start-new').addEventListener('click', createNewCharacter);
            document.getElementById('show-token-input').addEventListener('click', function() {
                document.getElementById('token-import').classList.toggle('hidden');
            });
            document.getElementById('import-token').addEventListener('click', importCharacter);
            document.getElementById('copy-token').addEventListener('click', copyTokenToClipboard);
            document.getElementById('close-token').addEventListener('click', function() {
                hideElement(reconnectToken);
            });
            
            // Chat functionality
            chatInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const message = chatInput.value.trim();
                    if (message) {
                        sendChatMessage(message);
                        chatInput.value = '';
                    }
                }
            });
            
            if (!isLoggedIn) {
                // If no saved character, just show the creation screen
                showElement(characterCreation);
            }
        }

        // Initialize the 3D game world
        function initGameWorld() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x243447); // Dark blue background
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 10);
            camera.lookAt(0, 0, 0);
            
            // Basic lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Create groups for organization
            worldGroup = new THREE.Group();
            itemsGroup = new THREE.Group();
            playerGroup = new THREE.Group();
            scene.add(worldGroup);
            scene.add(itemsGroup);
            scene.add(playerGroup);
            
            // Create player character
            playerMesh = createCharacterMesh(gameState.player.class);
            playerMesh.position.set(
                gameState.player.position.x, 
                gameState.player.position.y, 
                gameState.player.position.z
            );
            playerGroup.add(playerMesh);
            
            // Add a nametag above the player
            createPlayerNameTag(playerMesh, gameState.player.name);
            
            // Setup camera to follow player
            camera.position.set(
                playerMesh.position.x, 
                playerMesh.position.y + 8, 
                playerMesh.position.z + 8
            );
            camera.lookAt(playerMesh.position);
            
            // Generate initial world chunks
            generateInitialWorld();
            
            // Setup clock for animations
            clock = new THREE.Clock();
            
            // Setup keyboard controls
            setupControls();
            
            // Start game loop
            animate();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Create basic character mesh based on class
        function createCharacterMesh(characterClass) {
            let color;
            switch(characterClass) {
                case 'warrior': color = 0xcc3333; break;
                case 'mage': color = 0x3366cc; break;
                case 'ranger': color = 0x33cc66; break;
                default: color = 0xcccccc;
            }
            
            // Create a simple character model
            const character = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 0.7, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.35;
            character.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.85;
            character.add(head);
            
            return character;
        }

        // Add name tag above player
        function createPlayerNameTag(playerMesh, name) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = '#222222';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(name, canvas.width / 2, canvas.height / 2 + 8);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.y = 1.5;
            sprite.scale.set(2, 0.5, 1);
            
            playerMesh.add(sprite);
            return sprite;
        }

        // Generate the initial world chunks
        function generateInitialWorld() {
            showLoadingIndicator('Generating world...');
            
            // Create a basic ground plane
            const groundGeometry = new THREE.PlaneGeometry(
                CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE, 
                CONFIG.WORLD_SIZE * CONFIG.TILE_SIZE
            );
            groundGeometry.rotateX(-Math.PI / 2);
            
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x507744,
                side: THREE.DoubleSide
            });
            
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            worldGroup.add(ground);
            
            // Add some random obstacles and decoration
            addWorldDecoration();
            
            hideLoadingIndicator();
        }

        // Add decorative elements to the world
        function addWorldDecoration() {
            // Add trees
            for (let i = 0; i < 50; i++) {
                const x = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place trees at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createTree(x, 0, z);
            }
            
            // Add rocks
            for (let i = 0; i < 30; i++) {
                const x = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                const z = (Math.random() * CONFIG.WORLD_SIZE - CONFIG.WORLD_SIZE/2) * CONFIG.TILE_SIZE;
                
                // Don't place rocks at the spawn point
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                createRock(x, 0, z);
            }
            
            // Add a simple house
            createHouse(10, 0, 10);
        }

        // Create a simple tree
        function createTree(x, y, z) {
            const tree = new THREE.Group();
            
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.75;
            tree.add(trunk);
            
            // Tree leaves
            const leavesGeometry = new THREE.ConeGeometry(1, 2, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x2D572C });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 2.5;
            tree.add(leaves);
            
            tree.position.set(x, y, z);
            worldGroup.add(tree);
        }

        // Create a simple rock
        function createRock(x, y, z) {
            const rockGeometry = new THREE.DodecahedronGeometry(0.5, 0);
            const rockMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            
            rock.position.set(x, y + 0.25, z);
            rock.rotation.set(
                Math.random() * Math.PI, 
                Math.random() * Math.PI, 
                Math.random() * Math.PI
            );
            rock.scale.set(
                0.7 + Math.random() * 0.6,
                0.7 + Math.random() * 0.6,
                0.7 + Math.random() * 0.6
            );
            
            worldGroup.add(rock);
        }

        // Create a simple house
        function createHouse(x, y, z) {
            const house = new THREE.Group();
            
            // House base
            const baseGeometry = new THREE.BoxGeometry(5, 2.5, 4);
            const baseMaterial = new THREE.MeshLambertMaterial({ color: 0xDDCCAA });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1.25;
            house.add(base);
            
            // House roof
            const roofGeometry = new THREE.ConeGeometry(3.5, 2, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ color: 0xAA3333 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 3.5;
            roof.rotation.y = Math.PI / 4;
            house.add(roof);
            
            // Door
            const doorGeometry = new THREE.PlaneGeometry(1, 1.8);
            const doorMaterial = new THREE.MeshLambertMaterial({ color: 0x663300, side: THREE.DoubleSide });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 0.9, 2.01);
            house.add(door);
            
            // Windows
            const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const windowMaterial = new THREE.MeshLambertMaterial({ color: 0x88CCFF, side: THREE.DoubleSide });
            
            const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
            window1.position.set(-1.5, 1.5, 2.01);
            house.add(window1);
            
            const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
            window2.position.set(1.5, 1.5, 2.01);
            house.add(window2);
            
            house.position.set(x, y, z);
            worldGroup.add(house);
        }

        // Setup keyboard controls
        function setupControls() {
            const keysPressed = {};
            
            document.addEventListener('keydown', (event) => {
                keysPressed[event.key.toLowerCase()] = true;
                
                // Tab key to toggle player list details
                if (event.key === 'Tab') {
                    event.preventDefault(); // Prevent tab from changing focus
                    playerList.classList.toggle('expanded');
                }
            });
            
            document.addEventListener('keyup', (event) => {
                keysPressed[event.key.toLowerCase()] = false;
                
                // Additional key actions
                if (event.key === 'c' || event.key === 'C') {
                    toggleChat();
                }
                
                if (event.key === 'i' || event.key === 'I') {
                    toggleInventory();
                }
                
                if (event.key === 't' || event.key === 'T') {
                    showTokenDialog();
                }
            });
            
            // Setup mobile controls
            setupMobileControls();
            
            // Movement and controls update in animation loop
            controls = {
                keysPressed: keysPressed,
                moveDirection: new THREE.Vector3(),
                speed: CONFIG.MOVEMENT_SPEED,
                
                update: function(delta) {
                    const moveDirection = new THREE.Vector3();
                    
                    if (this.keysPressed['w'] || this.keysPressed['arrowup']) moveDirection.z -= 1;
                    if (this.keysPressed['s'] || this.keysPressed['arrowdown']) moveDirection.z += 1;
                    if (this.keysPressed['a'] || this.keysPressed['arrowleft']) moveDirection.x -= 1;
                    if (this.keysPressed['d'] || this.keysPressed['arrowright']) moveDirection.x += 1;
                    
                    if (moveDirection.length() > 0) {
                        moveDirection.normalize();
                        
                        // Move the player
                        playerMesh.position.x += moveDirection.x * this.speed * delta;
                        playerMesh.position.z += moveDirection.z * this.speed * delta;
                        
                        // Update player direction
                        if (moveDirection.x !== 0 || moveDirection.z !== 0) {
                            playerMesh.rotation.y = Math.atan2(moveDirection.x, moveDirection.z);
                        }
                        
                        // Update camera position
                        camera.position.x = playerMesh.position.x;
                        camera.position.z = playerMesh.position.z + 8;
                        camera.lookAt(playerMesh.position);
                        
                        // Update game state
                        gameState.player.position = {
                            x: playerMesh.position.x,
                            y: playerMesh.position.y,
                            z: playerMesh.position.z
                        };
                        
                        // Send position update to server
                        sendPositionUpdate();
                    }
                }
            };
        }
        
        // Setup mobile controls
        function setupMobileControls() {
            // Show mobile controls on touch devices
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            
            if (isTouchDevice) {
                const mobileControls = document.getElementById('mobile-controls');
                showElement(mobileControls);
                
                // Setup D-pad controls
                const btnUp = document.getElementById('btn-up');
                const btnDown = document.getElementById('btn-down');
                const btnLeft = document.getElementById('btn-left');
                const btnRight = document.getElementById('btn-right');
                const btnChat = document.getElementById('btn-chat');
                const btnInventory = document.getElementById('btn-inventory');
                
                // Function to handle button press
                function handleButtonPress(key, isPressed) {
                    controls.keysPressed[key] = isPressed;
                }
                
                // Up button
                btnUp.addEventListener('touchstart', () => handleButtonPress('arrowup', true));
                btnUp.addEventListener('touchend', () => handleButtonPress('arrowup', false));
                
                // Down button
                btnDown.addEventListener('touchstart', () => handleButtonPress('arrowdown', true));
                btnDown.addEventListener('touchend', () => handleButtonPress('arrowdown', false));
                
                // Left button
                btnLeft.addEventListener('touchstart', () => handleButtonPress('arrowleft', true));
                btnLeft.addEventListener('touchend', () => handleButtonPress('arrowleft', false));
                
                // Right button
                btnRight.addEventListener('touchstart', () => handleButtonPress('arrowright', true));
                btnRight.addEventListener('touchend', () => handleButtonPress('arrowright', false));
                
                // Chat button
                btnChat.addEventListener('touchend', toggleChat);
                
                // Inventory button
                btnInventory.addEventListener('touchend', toggleInventory);
                
                // Allow player list to toggle on click/tap
                playerList.addEventListener('click', () => {
                    playerList.classList.toggle('expanded');
                });
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            gameState.gameTime += delta;
            
            // Update controls
            if (controls) controls.update(delta);
            
            // Periodically save character
            if (gameState.gameTime - gameState.lastSaveTime > CONFIG.SAVE_INTERVAL / 1000) {
                saveCharacter();
                gameState.lastSaveTime = gameState.gameTime;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Create a new character
        function createNewCharacter() {
            const name = document.getElementById('character-name').value.trim();
            const characterClass = document.getElementById('character-class').value;
            
            if (!name) {
                alert('Please enter a character name');
                return;
            }
            
            // Create new character
            gameState.player = {
                id: generateUUID(),
                name: name,
                class: characterClass,
                level: 1,
                experience: 0,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                inventory: [],
                position: { x: 0, y: 0, z: 0 },
                created: new Date().toISOString()
            };
            
            // Save character to localStorage
            saveCharacter();
            
            // Update UI
            document.getElementById('char-name').textContent = gameState.player.name;
            document.getElementById('char-level').textContent = gameState.player.level;
            updateHealthMana();
            
            // Hide character creation and show game UI
            hideElement(characterCreation);
            showGameUI();
            
            // Initialize game world
            initGameWorld();
            
            // Connect to server
            connectToServer();
            
            // Show character token
            showTokenDialog();
        }

        // Import character from token
        function importCharacter() {
            const tokenInput = document.getElementById('token-input').value.trim();
            
            if (!tokenInput) {
                alert('Please enter a valid character token');
                return;
            }
            
            try {
                const decodedToken = atob(tokenInput);
                const characterData = JSON.parse(decodedToken);
                
                // Validate character data
                if (!characterData.id || !characterData.name || !characterData.class) {
                    throw new Error('Invalid character data');
                }
                
                // Set as current character
                gameState.player = characterData;
                
                // Save to localStorage
                saveCharacter();
                
                // Update UI
                document.getElementById('char-name').textContent = gameState.player.name;
                document.getElementById('char-level').textContent = gameState.player.level;
                updateHealthMana();
                
                // Hide character creation and show game UI
                hideElement(characterCreation);
                showGameUI();
                
                // Initialize game world
                initGameWorld();
                
                // Connect to server
                connectToServer();
                
                addSystemMessage('Character imported successfully!');
            } catch (e) {
                console.error('Error importing character', e);
                alert('Invalid character token. Please try again.');
            }
        }

        // Show the character token dialog
        function showTokenDialog() {
            const tokenText = document.getElementById('token-text');
            tokenText.textContent = btoa(JSON.stringify(gameState.player));
            showElement(reconnectToken);
        }

        // Copy token to clipboard
        function copyTokenToClipboard() {
            const tokenText = document.getElementById('token-text').textContent;
            navigator.clipboard.writeText(tokenText)
                .then(() => {
                    alert('Token copied to clipboard!');
                })
                .catch(err => {
                    console.error('Error copying token', err);
                    alert('Failed to copy token. Please select and copy it manually.');
                });
        }

        // Connect to WebSocket server
        function connectToServer() {
            showLoadingIndicator('Connecting to server...');
            updateConnectionStatus('connecting', 'Connecting to server...');
            
            // Create WebSocket connection
            websocket = new WebSocket(CONFIG.WEBSOCKET_URL);
            
            websocket.onopen = function() {
                console.log('Connected to server');
                hideLoadingIndicator();
                updateConnectionStatus('connected', 'Connected');
                
                // Send initial player data
                const initialData = {
                    type: 'player_join',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        class: gameState.player.class,
                        position: gameState.player.position,
                        level: gameState.player.level,
                        health: gameState.player.health,
                        maxHealth: gameState.player.maxHealth
                    }
                };
                
                websocket.send(JSON.stringify(initialData));
                addSystemMessage('Connected to server. Welcome to Pixel Kingdom!');
            };
            
            websocket.onmessage = function(event) {
                handleServerMessage(event.data);
            };
            
            websocket.onclose = function() {
                console.log('Disconnected from server');
                updateConnectionStatus('disconnected', 'Disconnected. Reconnecting...');
                addSystemMessage('Disconnected from server. Attempting to reconnect...');
                
                // Try to reconnect after a delay
                setTimeout(connectToServer, 3000);
            };
            
            websocket.onerror = function(error) {
                console.error('WebSocket error:', error);
                hideLoadingIndicator();
                updateConnectionStatus('disconnected', 'Connection error');
                addSystemMessage('Connection error. Please try again later.');
            };
        }
        
        // Update connection status display
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connection-status');
            
            // Remove all status classes
            statusElement.classList.remove('connecting', 'connected', 'disconnected');
            
            // Add the current status class
            statusElement.classList.add(status);
            
            // Set the status message
            statusElement.textContent = message;
            
            // Auto-hide the status after 3 seconds if connected
            if (status === 'connected') {
                setTimeout(() => {
                    statusElement.style.opacity = '0';
                }, 3000);
            } else {
                statusElement.style.opacity = '1';
            }
        }

        // Handle messages from the server
        function handleServerMessage(message) {
            try {
                const data = JSON.parse(message);
                
                switch (data.type) {
                    case 'player_join':
                        // Only process if it's not our own join message
                        if (data.player.id !== gameState.player.id) {
                            addOtherPlayer(data.player);
                            addSystemMessage(`${data.player.name} has joined the game!`);
                            updatePlayerList();
                        }
                        break;
                        
                    case 'player_position':
                        // Update other player position
                        if (data.player.id !== gameState.player.id) {
                            updateOtherPlayerPosition(data.player);
                        }
                        break;
                        
                    case 'chat_message':
                        // Display chat message from other players
                        if (data.player.id !== gameState.player.id) {
                            addPlayerMessage(data.player.name, data.message);
                        }
                        break;
                        
                    case 'player_leave':
                        // Remove player who disconnected
                        if (data.playerId && gameState.otherPlayers[data.playerId]) {
                            removeOtherPlayer(data.playerId);
                            updatePlayerList();
                        }
                        break;
                        
                    case 'npc_info':
                        // Add NPC to the game
                        if (data.npc) {
                            addNpcToGame(data.npc);
                        }
                        break;
                        
                    case 'item_info':
                        // Add item to the game
                        if (data.item) {
                            addItemToGame(data.item);
                        }
                        break;
                }
            } catch (e) {
                console.error('Error parsing server message', e);
            }
        }

        // Send position update to server
        function sendPositionUpdate() {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const updateData = {
                    type: 'player_position',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name,
                        position: gameState.player.position
                    }
                };
                
                websocket.send(JSON.stringify(updateData));
            }
        }

        // Send chat message
        function sendChatMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const chatData = {
                    type: 'chat_message',
                    player: {
                        id: gameState.player.id,
                        name: gameState.player.name
                    },
                    message: message
                };
                
                websocket.send(JSON.stringify(chatData));
                addPlayerMessage(gameState.player.name, message);
            } else {
                addSystemMessage('You are not connected to the server.');
            }
        }

        // Add another player to the game
        function addOtherPlayer(playerData) {
            // Check if player already exists
            if (gameState.otherPlayers[playerData.id]) {
                return;
            }
            
            // Create player mesh
            const otherPlayerMesh = createCharacterMesh(playerData.class);
            otherPlayerMesh.position.set(
                playerData.position.x,
                playerData.position.y,
                playerData.position.z
            );
            
            // Add name tag
            createPlayerNameTag(otherPlayerMesh, playerData.name);
            
            // Add to scene
            playerGroup.add(otherPlayerMesh);
            
            // Store player data
            gameState.otherPlayers[playerData.id] = {
                data: playerData,
                mesh: otherPlayerMesh
            };
            
            updatePlayerList();
        }
        
        // Remove other player from the game
        function removeOtherPlayer(playerId) {
            const player = gameState.otherPlayers[playerId];
            if (player && player.mesh) {
                playerGroup.remove(player.mesh);
                delete gameState.otherPlayers[playerId];
                addSystemMessage(`${player.data.name} has left the game.`);
            }
        }

        // Update other player position
        function updateOtherPlayerPosition(playerData) {
            const player = gameState.otherPlayers[playerData.id];
            
            if (player && player.mesh) {
                // Smoothly move to new position
                const targetPosition = new THREE.Vector3(
                    playerData.position.x,
                    playerData.position.y,
                    playerData.position.z
                );
                
                const currentPosition = player.mesh.position;
                currentPosition.lerp(targetPosition, 0.5);
                
                // Update stored data
                player.data.position = playerData.position;
            }
        }
        
        // Add NPC to the game
        function addNpcToGame(npcData) {
            // Implementation will be added later
            console.log('NPC added:', npcData);
        }
        
        // Add item to the game
        function addItemToGame(itemData) {
            // Implementation will be added later
            console.log('Item added:', itemData);
        }

        // Update the player list UI
        function updatePlayerList() {
            // Update player count
            const playerCount = 1 + Object.keys(gameState.otherPlayers).length; // Current player + others
            document.getElementById('online-count').textContent = playerCount;
            
            // Clear the list
            const playerDetails = document.getElementById('player-details');
            playerDetails.innerHTML = '';
            
            // Add the current player
            const currentPlayerItem = document.createElement('div');
            currentPlayerItem.className = 'player-item';
            
            const currentPlayerName = document.createElement('div');
            currentPlayerName.className = 'player-name';
            currentPlayerName.textContent = `${gameState.player.name} (You)`;
            
            const currentPlayerInfo = document.createElement('div');
            currentPlayerInfo.className = 'player-info';
            
            const currentPlayerLevel = document.createElement('span');
            currentPlayerLevel.textContent = `Lvl ${gameState.player.level}`;
            
            const healthIndicator = document.createElement('div');
            healthIndicator.className = 'health-indicator';
            healthIndicator.style.backgroundColor = getHealthColor(gameState.player.health, gameState.player.maxHealth);
            
            currentPlayerInfo.appendChild(currentPlayerLevel);
            currentPlayerInfo.appendChild(healthIndicator);
            
            currentPlayerItem.appendChild(currentPlayerName);
            currentPlayerItem.appendChild(currentPlayerInfo);
            playerDetails.appendChild(currentPlayerItem);
            
            // Add other players
            const playerIds = Object.keys(gameState.otherPlayers);
            
            playerIds.forEach(id => {
                const player = gameState.otherPlayers[id];
                
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                
                const playerName = document.createElement('div');
                playerName.className = 'player-name';
                playerName.textContent = player.data.name;
                
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                
                const playerLevel = document.createElement('span');
                // Use level from player data if available, default to 1
                const level = player.data.level || 1;
                playerLevel.textContent = `Lvl ${level}`;
                
                const healthInd = document.createElement('div');
                healthInd.className = 'health-indicator';
                // Default to full health if not specified
                const health = player.data.health || 100;
                const maxHealth = player.data.maxHealth || 100;
                healthInd.style.backgroundColor = getHealthColor(health, maxHealth);
                
                playerInfo.appendChild(playerLevel);
                playerInfo.appendChild(healthInd);
                
                playerItem.appendChild(playerName);
                playerItem.appendChild(playerInfo);
                playerDetails.appendChild(playerItem);
            });
        }
        
        // Get color based on health percentage
        function getHealthColor(health, maxHealth) {
            const healthPercent = health / maxHealth;
            
            if (healthPercent > 0.7) {
                return '#33cc33'; // Green
            } else if (healthPercent > 0.3) {
                return '#ffcc00'; // Yellow
            } else {
                return '#cc3333'; // Red
            }
        }

        // Add system message to chat
        function addSystemMessage(message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-system';
            messageElement.textContent = `System: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Add player message to chat
        function addPlayerMessage(playerName, message) {
            const messageElement = document.createElement('div');
            messageElement.className = 'chat-message chat-player';
            messageElement.textContent = `${playerName}: ${message}`;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Toggle chat visibility
        function toggleChat() {
            chatUI.classList.toggle('hidden');
            if (!chatUI.classList.contains('hidden')) {
                chatInput.focus();
            }
        }

        // Toggle inventory visibility
        function toggleInventory() {
            inventory.classList.toggle('hidden');
        }

        // Update health and mana bars
        function updateHealthMana() {
            const healthFill = document.getElementById('health-fill');
            const manaFill = document.getElementById('mana-fill');
            
            const healthText = healthBar.querySelector('.progress-text');
            const manaText = manaBar.querySelector('.progress-text');
            
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const manaPercent = (gameState.player.mana / gameState.player.maxMana) * 100;
            
            healthFill.style.width = `${healthPercent}%`;
            manaFill.style.width = `${manaPercent}%`;
            
            healthText.textContent = `${gameState.player.health}/${gameState.player.maxHealth}`;
            manaText.textContent = `${gameState.player.mana}/${gameState.player.maxMana}`;
        }

        // Save character to localStorage
        function saveCharacter() {
            localStorage.setItem('pixelRealmsCharacter', JSON.stringify(gameState.player));
        }

        // Show game UI elements
        function showGameUI() {
            showElement(statsUI);
            showElement(chatUI);
            showElement(playerList);
            showElement(healthBar);
            showElement(manaBar);
            showElement(inventory);
        }

        // Show element by removing hidden class
        function showElement(element) {
            element.classList.remove('hidden');
        }

        // Hide element by adding hidden class
        function hideElement(element) {
            element.classList.add('hidden');
        }

        // Show loading indicator
        function showLoadingIndicator(message) {
            const indicator = document.getElementById('loading-indicator');
            indicator.textContent = message || 'Loading...';
            indicator.classList.add('active');
        }

        // Hide loading indicator
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            indicator.classList.remove('active');
        }

        // Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Start the game
        init();
    </script>
</body>
</html>
